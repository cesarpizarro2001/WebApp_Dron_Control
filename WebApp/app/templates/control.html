<!--Este es el fichero que enviar치 el servidor web al navegador cuando 칠ste se conecte a la web-->

<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no, maximum-scale=1.0, minimum-scale=1.0">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <title>Web App</title>
    
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.3/dist/leaflet.css" />
    <!--    Necesito estos scripts para trabajar con websockets (Socket.IO)-->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/socket.io/4.0.1/socket.io.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/js/bootstrap.bundle.min.js"></script>
    <script>
        // Detectar si es un dispositivo t치ctil
        function isTouchDevice() {
            return (('ontouchstart' in window) ||
                   (navigator.maxTouchPoints > 0) ||
                   (navigator.msMaxTouchPoints > 0));
        }
        
        // Variable global para saber si es t치ctil
        const IS_TOUCH_DEVICE = isTouchDevice();
        console.log('Dispositivo t치ctil detectado:', IS_TOUCH_DEVICE);
    </script>
</head>
<style>
        /* === ESTILOS B츼SICOS === */
        body { 
            margin: 0; 
            padding: 0; 
        }
        
        /* === CONTENEDORES PRINCIPALES === */
        #map { 
            height: 100vh; 
            width: 100%; 
        }
        
        #webcam-container {
            height: 100vh;
            width: 100%;
            display: none;
            background-color: black;
            justify-content: center;
            align-items: center;
        }
        
        #webcam-video {
            max-width: 100%;
            max-height: 100%;
            object-fit: contain;
        }
        
        /* === TELEMETR칈A === */
        #datos-telemetria {
            position: absolute;
            top: 10px;
            left: 50px;
            background: rgba(255, 255, 255, 0.9);
            padding: 5px 10px;
            border-radius: 8px;
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.2);
            z-index: 1000;
            display: flex;
            gap: 30px;
            font-size: 15px;
            height: 30px;
            align-items: center;
            overflow: hidden;
        }
        
        .dato {
            font-weight: bold;
        }
        
        /* === CONTROLES === */
        .controls {
            position: absolute;
            top: 10px;
            right: 10px;
            background: rgba(255, 255, 255, 0.9);
            padding: 5px;
            border-radius: 8px;
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.2);
            z-index: 1000;
            max-width: 100px;
        }
        
        .controls button, .controls input {
            display: block;
            width: 100%;
            margin-bottom: 3px;
            padding: 4px;
            font-size: 13px;
            border-radius: 5px;
        }
        
        /* === BOTONES COLOREADOS === */
        .boton-verde { background-color: #4CAF50; color: white; }
        .boton-amarillo { background-color: #FFD700; color: black; }
        .boton-rojo { background-color: #f44336; color: white; }
        .boton-azul { background-color: #2196F3; color: white; }
        
        /* === INDICADOR MODO SEGUIMIENTO === */
        .follow-mode-indicator {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 60px;
            height: 60px;
            border: 3px solid #4CAF50;
            border-radius: 50%;
            background: rgba(76, 175, 80, 0.1);
            pointer-events: none;
            z-index: 1001;
            display: none;
            animation: pulse-follow 2s infinite;
        }
        
        @keyframes pulse-follow {
            0% { transform: translate(-50%, -50%) scale(1); opacity: 0.7; }
            50% { transform: translate(-50%, -50%) scale(1.1); opacity: 0.3; }
            100% { transform: translate(-50%, -50%) scale(1); opacity: 0.7; }
        }
        
        /* === JOYSTICK === */
        .joystick-area {
            position: absolute;
            left: 0;
            top: 0;
            width: 50%;
            height: 100vh;
            z-index: 500;
            pointer-events: auto;
            touch-action: none;
        }
        
        .joystick-container {
            position: fixed;
            bottom: 100px;
            left: 100px;
            width: 120px;
            height: 120px;
            background: rgba(255, 255, 255, 0.2);
            border: 3px solid rgba(255, 255, 255, 0.4);
            border-radius: 50%;
            display: none;
            z-index: 501;
            pointer-events: none;
            transition: opacity 0.2s ease;
        }
        
        .joystick-knob {
            position: absolute;
            width: 50px;
            height: 50px;
            background: rgba(66, 165, 245, 0.7);
            border: 2px solid rgba(33, 150, 243, 0.8);
            border-radius: 50%;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            pointer-events: none;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.2);
            transition: transform 0.1s ease;
        }
        
        .joystick-center-dot {
            position: absolute;
            width: 4px;
            height: 4px;
            background: rgba(255, 255, 255, 0.8);
            border-radius: 50%;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            pointer-events: none;
        }
        
        /* === CLASES DE VISIBILIDAD SEG칔N DISPOSITIVO === */
        /* Mostrar joystick solo en dispositivos t치ctiles */
        .joystick-container.touch-device {
            display: block;
            opacity: 0.8;
        }
        
        /* Ocultar cruceta en dispositivos t치ctiles */
        .navigation-grid.touch-hidden {
            display: none !important;
        }
        
        /* Ocultar joystick completamente en dispositivos no t치ctiles */
        .joystick-area.non-touch-hidden {
            display: none !important;
        }
        
        /* === UTILIDADES === */
        .direction-arrow { 
            pointer-events: none; 
        }
        
        /* Prevenir selecci칩n de texto en elementos t치ctiles */
        .joystick-area, .joystick-container, .joystick-knob {
            -webkit-user-select: none;
            -moz-user-select: none;
            -ms-user-select: none;
            user-select: none;
            -webkit-touch-callout: none;
            -webkit-tap-highlight-color: transparent;
        }
    </style>
<body>
    <div class="controls">
        <input type="number" id="altura" placeholder="Altura (m)" />
        <button id="botonConectar" onclick="conectarDron()">Conectar</button>
        <button id="botonDespegar" onclick="despegarDron()">Despegar</button>
        <button id="botonAterrizar" onclick="aterrizarDron()">Aterrizar</button>
        <button id="botonRTL" onclick="returnToLaunch()">RTL</button>
        <button id="botonRuta" class="boton-azul" onclick="toggleRutaMode()">Crear Ruta</button>
        <button id="botonImagenDron" class="boton-azul" onclick="toggleWebcamView()">C치mara Dron</button>
        <button id="botonCapturarFoto" class="boton-azul" onclick="capturarFoto()">Hacer Foto</button>
        <button id="botonIniciarVideo" class="boton-azul" onclick="iniciarGrabacion()">Hacer Video</button>
        <button id="botonDetenerVideo" class="boton-rojo" style="display:none;" onclick="detenerGrabacion()">Detener Video</button>
        <button id="botonCamaraMovil" class="boton-azul" onclick="abrirVentanaCamara()">C치mara M칩vil</button>
        <button id="toggleNavegacion" class="boton-azul" onclick="toggleNavegacion()">Ocultar Nav.</button>
        <button id="botonSeguirDron" class="boton-azul" onclick="toggleFollowDrone()">Seguir Dron</button>
        <button id="botonModoPiloto" class="boton-azul" onclick="irAModoPiloto()">游꿡 Modo Piloto</button>

    </div>

    <div id="navegacion" class="controls navigation-grid" style="
    display: grid;
    grid-template-columns: repeat(3, 1fr);
    gap: 3px;
    margin-top: 10px;
    width: 100%;
    max-width: 150px;
    position: absolute;
    top: 0px;
    right: 130px;
    ">
    <button onclick="moverDron('NorthWest')" style="grid-area: 1 / 1 / 2 / 2; background-color: #2196F3; color: white;">NW</button>
    <button onclick="moverDron('North')" style="grid-area: 1 / 2 / 2 / 3; background-color: #2196F3; color: white;">N</button>
    <button onclick="moverDron('NorthEast')" style="grid-area: 1 / 3 / 2 / 4; background-color: #2196F3; color: white;">NE</button>

    <button onclick="moverDron('West')" style="grid-area: 2 / 1 / 3 / 2; background-color: #2196F3; color: white;">W</button>
    <button onclick="moverDron('Stop')" style="grid-area: 2 / 2 / 3 / 3; background-color: #FF9800; color: white;">Stop</button>
    <button onclick="moverDron('East')" style="grid-area: 2 / 3 / 3 / 4; background-color: #2196F3; color: white;">E</button>

    <button onclick="moverDron('SouthWest')" style="grid-area: 3 / 1 / 4 / 2; background-color: #2196F3; color: white;">SW</button>
    <button onclick="moverDron('South')" style="grid-area: 3 / 2 / 4 / 3; background-color: #2196F3; color: white;">S</button>
    <button onclick="moverDron('SouthEast')" style="grid-area: 3 / 3 / 4 / 4; background-color: #2196F3; color: white;">SE</button>
    </div>

    <div id="datos-telemetria">
        <span><strong>Altitud:</strong> <span class="dato" id="altitud">0m</span></span>
        <span><strong>Velocidad:</strong> <span class="dato" id="velocidad">0m/s</span></span>
        <span><strong>Estado:</strong> <span class="dato" id="estado">Desconocido</span></span>
    </div>

    <div id="webcam-container" style="display: none; margin-top: 20px; text-align: center;">
        <h3>Video por WebSockets</h3>
        <img id='video-stream' style='width:100%; max-width:600px;'>
    </div>

    <div id="camara-container" style="display: none; margin-top: 20px; text-align: center;">
        <h3>Camara</h3>
        <div id="button-container">
            <button id="botonFront" class="boton" onclick="frontCamera()">C치mara frontal</button>
            <!-- <button id="botonBack" class="boton" onclick="backCamera() disabled">C치mara trasera</button> (Opci칩n de usar tambi칠n la c치mara trasera)-->
        </div>
        <video id="video" autoplay playsinline></video>
        <canvas id="canvas" style="display:none;"></canvas>
        <img id="processedStream" alt="Video Procesado">
    </div>

    <div id="map"></div>

    <!-- Indicador visual del modo seguimiento -->
    <div id="follow-indicator" class="follow-mode-indicator"></div>

    <!-- 츼rea del joystick flotante (mitad izquierda de la pantalla) -->
    <div class="joystick-area" id="joystick-area">
        <div class="joystick-container" id="joystick-container">
            <div class="joystick-center-dot"></div>
            <div class="joystick-knob" id="joystick-knob"></div>
        </div>
    </div>

<script src="https://unpkg.com/leaflet@1.9.3/dist/leaflet.js"></script>
<script>
        // Inicializar el mapa
        // ===== VARIABLES GLOBALES =====
        
        // Variables del mapa y posicionamiento
        var map = L.map('map').setView([41.27624, 1.98838], 20);
        L.tileLayer("https://mt1.google.com/vt/lyrs=s&x={x}&y={y}&z={z}", {
            maxZoom: 20
        }).addTo(map);

        // Variables globales para el seguimiento del dron
        let currentPos = [41.27624, 1.98838];
        let droneMarker = L.marker(currentPos, {
            icon: L.icon({
                iconUrl: 'static/icono_dron.png',
                iconSize: [30, 30],
                iconAnchor: [15, 15] // Centrar el icono
            }),
            zIndexOffset: 1000 // Asegurar que est칠 encima de otros elementos
        }).addTo(map);

        let currentFlightName = null;
        // Variables para la funcionalidad de ruta
        let rutaMode = false;
        let waypoints = [];
        let waypointMarkers = [];
        let siguiendoRuta = false;
        let rutaPolyline = L.polyline([], { color: 'black', weight: 3 }).addTo(map);
        let telemetry_info = null;
        
        // Variables para el seguimiento del dron
        let followDrone = false;
        let droneFollowButton = null;
        
        // ===== ICONOS Y MARCADORES =====

        // Funci칩n para manejar la orientaci칩n del dron
        function createArrowSVG(angle) {
        return `
        <svg width="300" height="300" viewBox="-150 -150 300 300" xmlns="http://www.w3.org/2000/svg">
            <g transform="rotate(${angle} 0 0)">
                <!-- L칤nea roja larga de direcci칩n -->
                <line x1="0" y1="0" x2="0" y2="-140" stroke="red" stroke-width="3"/>
            </g>
        </svg>
        `;
        }

        // Funci칩n para crear el SVG del marcador de waypoint en forma de pin
        function createWaypointPinSVG(number, color = "#FFC107") {
            return `
                <svg width="30" height="45" viewBox="0 0 40 60" xmlns="http://www.w3.org/2000/svg">
                    <path d="M20 0C9 0 0 9 0 20C0 35 20 60 20 60C20 60 40 35 40 20C40 9 31 0 20 0Z" fill="${color}" stroke="#000" stroke-width="1"/>
                    <circle cx="20" cy="20" r="10" fill="white"/>
                    <text x="20" y="24" font-family="Arial" font-size="12" font-weight="bold" text-anchor="middle">${number}</text>
                </svg>
            `;
        }

        var DirectionArrow = L.Icon.extend({
            options: {
                iconSize: [300, 300],
                iconAnchor: [150, 150]
            }
        });

        // Definir el icono de waypoint personalizado
        var WaypointIcon = L.Icon.extend({
            options: {
                iconSize: [30, 45],
                iconAnchor: [15, 45],  // Punto de anclaje en la punta inferior del pin
                popupAnchor: [0, -45]  // Punto de anclaje para popups
            }
        });

        let directionArrow = L.marker(currentPos, {
            icon: new DirectionArrow({
                iconUrl: 'data:image/svg+xml;charset=utf-8,' + encodeURIComponent(createArrowSVG(0))
            })
        }).addTo(map);
        
        // ===== FUNCIONES DE MAPAS Y NAVEGACI칍N =====

        // Funci칩n para actualizar la posici칩n del dron
        function updateDronePosition(lat, lon, heading) {
            const newPos = [lat, lon];
            
            // Siempre actualizar la posici칩n real del dron
            droneMarker.setLatLng(newPos);
            directionArrow.setLatLng(newPos);
            
            // Si est치 en modo seguimiento, mover el mapa para mantener el dron centrado
            if (followDrone) {
                map.setView(newPos, map.getZoom(), {animate: true, duration: 0.3});
            }
            
            // Actualizar la direcci칩n de la flecha
            directionArrow.setIcon(new DirectionArrow({
                iconUrl: 'data:image/svg+xml;charset=utf-8,' + encodeURIComponent(createArrowSVG(heading))
            }));

            currentPos = newPos;

            // Comprobar si est치 siguiendo una ruta y verificar si ha alcanzado un waypoint
            if (siguiendoRuta && waypoints.length > 0) {
                checkWaypointReached();
            }
        }

        // Funci칩n de Waypoint alcanzado
        function checkWaypointReached() {
            // Si no hay waypoints, no hay nada que verificar
            if (waypoints.length === 0) return;

            // Obtener el primer waypoint (el pr칩ximo destino)
            const nextWaypoint = waypoints[0];

            // Calcular la distancia entre el dron y el waypoint
            const droneLatLng = L.latLng(currentPos[0], currentPos[1]);
            const waypointLatLng = L.latLng(nextWaypoint.lat, nextWaypoint.lng);
            const distance = droneLatLng.distanceTo(waypointLatLng);

            // Si el dron est치 a menos de 3 metros del waypoint, consideramos que ha llegado
            if (distance < 3) {
                // Eliminar el waypoint alcanzado
                waypoints.shift();

                // Eliminar el marcador del waypoint
                if (waypointMarkers.length > 0) {
                    map.removeLayer(waypointMarkers[0]);
                    waypointMarkers.shift();
                }

                // Si quedan m치s waypoints, ir al siguiente
                if (waypoints.length > 0) {
                    const nextWaypoint = waypoints[0];
                    moverDronAWaypoint(nextWaypoint);
                } else {
                    // Si no quedan m치s waypoints, terminar la ruta
                    finalizarRuta();
                }
            }
        }

        // Funci칩n que indica fin de la ruta
        function finalizarRuta() {
            siguiendoRuta = false;

            // Limpiar la l칤nea de la ruta
            rutaPolyline.setLatLngs([]);

            // Cambiar el bot칩n de vuelta a "Crear Ruta"
            const botonRuta = document.getElementById('botonRuta');
            botonRuta.textContent = "Crear Ruta";
            botonRuta.classList.remove('boton-rojo');
            botonRuta.classList.add('boton-azul');

            // Habilitar los otros botones
            document.getElementById('botonConectar').disabled = false;
            document.getElementById('botonDespegar').disabled = false;


            waypoints = [];
            waypointMarkers.forEach(m => map.removeLayer(m));
            waypointMarkers = [];
            rutaPolyline.setLatLngs([]);  // <-- Esta l칤nea asegura borrar la l칤nea negra

        }

        // Manejar clicks en el mapa
        map.on('click', function(e) {
            // Si estamos en modo ruta, a침adir waypoint
            if (rutaMode) {
                addWaypoint(e.latlng);
                return;
            }

            // Si estamos siguiendo una ruta, ignorar clicks
            if (siguiendoRuta) {
                return;
            }

            // Comportamiento normal: ir a la posici칩n clickeada
            const targetPos = [e.latlng.lat, e.latlng.lng];
            mover_dron_a_coordenadas(targetPos[0], targetPos[1]);
        });

        // A침adir Waypoint para la ruta
       function addWaypoint(latlng) {
            const waypointNum = waypoints.length + 1;

            // Crear contenedor flotante para elegir tipo de captura
            const popupDiv = document.createElement("div");

            popupDiv.innerHTML = `
                <label style="font-size: 14px;">Captura en este waypoint:</label><br>
                <select id="capturaTipo">
                    <option value="ninguna" selected>Ninguna</option>
                    <option value="foto">Foto</option>
                    <option value="video">V칤deo</option>
                </select><br>
                <div id="duracionDiv" style="display:none;">
                    <label for="duracionInput">Duraci칩n v칤deo (seg):</label>
                    <input type="number" id="duracionInput" value="5" min="1" style="width:60px;" />
                </div>
                <button id="confirmarWaypointBtn">Confirmar</button>
            `;

            const popup = L.popup()
                .setLatLng(latlng)
                .setContent(popupDiv)
                .openOn(map);

            // Mostrar para escoger duraci칩n si se elige video
            popupDiv.querySelector("#capturaTipo").addEventListener("change", function () {
                popupDiv.querySelector("#duracionDiv").style.display = this.value === "video" ? "block" : "none";
            });

            // Confirmar y cerrar
            popupDiv.querySelector("#confirmarWaypointBtn").addEventListener("click", () => {
                const tipo = popupDiv.querySelector("#capturaTipo").value;
                const duracion = tipo === "video" ? parseInt(popupDiv.querySelector("#duracionInput").value) : 0;

                // Guardar el waypoint
                waypoints.push({
                    lat: latlng.lat,
                    lng: latlng.lng,
                    num: waypointNum,
                    captura: tipo,
                    duracion: duracion
                });

                // Elegir color seg칰n tipo
                let color = "#FFC107"; // Ninguna
                if (tipo === "foto") color = "#2196F3"; // Azul
                else if (tipo === "video") color = "#F44336"; // Rojo

                const waypointIcon = new WaypointIcon({
                    iconUrl: 'data:image/svg+xml;charset=utf-8,' + encodeURIComponent(createWaypointPinSVG(waypointNum, color))
                });

                const marker = L.marker([latlng.lat, latlng.lng], { icon: waypointIcon }).addTo(map);
                waypointMarkers.push(marker);

                actualizarRutaPolyline();
                map.closePopup();
            });
        }

        // Actualiza la l칤nea negra de la ruta
        function actualizarRutaPolyline() {
            const coordenadas = waypoints.map(wp => [wp.lat, wp.lng]);
            rutaPolyline.setLatLngs(coordenadas);
        }

        // Muestra u oculta la botonera de navegaci칩n cl치sica
        function toggleNavegacion() {
            const nav = document.getElementById('navegacion');
            const btn = document.getElementById('toggleNavegacion');

            if (nav.style.display === 'none') {
                nav.style.display = 'grid';
                btn.textContent = 'Ocultar Nav.';
            } else {
                nav.style.display = 'none';
                btn.textContent = 'Mostrar Nav.';
            }
        }

        // Funci칩n para activar/desactivar el seguimiento del dron
        function toggleFollowDrone() {
            const botonSeguir = document.getElementById('botonSeguirDron');
            const followIndicator = document.getElementById('follow-indicator');
            
            followDrone = !followDrone;
            
            if (followDrone) {
                // Activar modo seguimiento
                botonSeguir.textContent = "Dejar de Seguir";
                botonSeguir.classList.remove('boton-azul');
                botonSeguir.classList.add('boton-verde');
                
                // Mostrar indicador visual
                // followIndicator.style.display = 'block'; // Comentado para quitar el c칤rculo verde
                
                // Centrar inmediatamente en el dron
                map.setView(currentPos, map.getZoom());
                
                console.log('Modo seguimiento activado: El mapa seguir치 al dron');
            } else {
                // Desactivar modo seguimiento
                botonSeguir.textContent = "Seguir Dron";
                botonSeguir.classList.remove('boton-verde');
                botonSeguir.classList.add('boton-azul');
                
                // Ocultar indicador visual
                // followIndicator.style.display = 'none'; // Comentado para quitar el c칤rculo verde
                
                console.log('Modo seguimiento desactivado');
            }
        }

        // Cambia el bot칩n crear ruta a otro tipo de informaci칩n (Recorrer ruta)
        function toggleRutaMode() {
            const botonRuta = document.getElementById('botonRuta');

            // Si ya estamos siguiendo una ruta, no hacemos nada
            if (siguiendoRuta) return;

            if (!rutaMode) {
                // Activar modo de creaci칩n de ruta
                rutaMode = true;
                botonRuta.textContent = "Recorrer Ruta";
                botonRuta.classList.remove('boton-azul');
                botonRuta.classList.add('boton-amarillo');
            } else {
                // Si hay waypoints, iniciar la ruta
                if (waypoints.length > 0) {
                    iniciarRuta();
                } else {
                    // Si no hay waypoints, volver al modo normal
                    rutaMode = false;
                    botonRuta.textContent = "Crear Ruta";
                    botonRuta.classList.remove('boton-amarillo');
                    botonRuta.classList.add('boton-azul');
                }
            }
        }

        // Funci칩n que indica el inicio de una ruta y cambia el bot칩n a: siguiendo ruta
        function iniciarRuta() {
            siguiendoRuta = true;
            rutaMode = false;

            const botonRuta = document.getElementById('botonRuta');
            botonRuta.textContent = "Siguiendo Ruta...";
            botonRuta.classList.remove('boton-amarillo');
            botonRuta.classList.add('boton-rojo');

            // Deshabilitar los otros botones
            document.getElementById('botonConectar').disabled = true;
            document.getElementById('botonDespegar').disabled = true;

            socket.emit('command', { action: 'waypointRuta', waypoints: waypoints });
        }

        // Mover el dron al waypoint indicado
        function moverDronAWaypoint(waypoint) {
            mover_dron_a_coordenadas(waypoint.lat, waypoint.lng);
            console.log('Dron movi칠ndose al waypoint:', waypoint.num);
        }
        
        // ===== FUNCIONES DE WEBCAM Y CAPTURA =====

        // Funci칩n para mostrar u ocultar el contenedor de video
        function toggleWebcamView() {
            const webcamContainer = document.getElementById('webcam-container');
            if (webcamContainer.style.display === 'none') {
                webcamContainer.style.display = 'block';
                document.getElementById('botonImagenDron').textContent = 'Ver Mapa';
            } else {
                webcamContainer.style.display = 'none';
                document.getElementById('botonImagenDron').textContent = 'C치mara Dron';
            }
        }

        // Funci칩n para mostrar u ocultar el contenedor de la c치mara del m칩vil
        function abrirVentanaCamara() {
            const camaraContainer = document.getElementById('camara-container');
            if (camaraContainer.style.display === 'none') {
                camaraContainer.style.display = 'block';
                document.getElementById('botonCamaraMovil').textContent = 'Ver Mapa';
                alert("Ponga el m칩vil en vertical y oculte los botones de navegaci칩n para optimizar el uso de esta funci칩n.");
            } else {
                camaraContainer.style.display = 'none';
                document.getElementById('botonCamaraMovil').textContent = 'C치mara M칩vil';
            }
        }

        // Funci칩n para ir al modo piloto
        function irAModoPiloto() {
            window.location.href = '/piloto';
        }

        // Funci칩n de capturar foto
        function capturarFoto() {
            console.log("Enviando comando para capturar foto");
            socket.emit('command', { action: 'capturarFoto' });
            // Mostrar feedback visual moment치neo
            const botonCapturarFoto = document.getElementById('botonCapturarFoto');
            botonCapturarFoto.classList.remove('boton-azul');
            botonCapturarFoto.classList.add('boton-verde');
            botonCapturarFoto.textContent = "Foto Hecha";

            // Restaurar el bot칩n despu칠s de 2 segundos
            setTimeout(function() {
                botonCapturarFoto.classList.remove('boton-verde');
                botonCapturarFoto.classList.add('boton-azul');
                botonCapturarFoto.textContent = "Hacer Foto";
            }, 2000);
        }

        // Inicia la grabaci칩n del v칤deo de la c치mara del dron
        function iniciarGrabacion() {
            console.log("Enviando comando para iniciar grabaci칩n de video");
            socket.emit('command', { action: 'iniciarVideo' });

            // Mostrar feedback visual
            const botonIniciarVideo = document.getElementById('botonIniciarVideo');
            const botonDetenerVideo = document.getElementById('botonDetenerVideo');

            botonIniciarVideo.style.display = 'none';
            botonDetenerVideo.style.display = 'block';
        }

         // Detiene la grabaci칩n del v칤deo de la c치mara del dron
        function detenerGrabacion() {
            console.log("Enviando comando para detener grabaci칩n de video");
            socket.emit('command', { action: 'detenerVideo' });

            // Mostrar feedback visual
            const botonIniciarVideo = document.getElementById('botonIniciarVideo');
            const botonDetenerVideo = document.getElementById('botonDetenerVideo');

            botonIniciarVideo.style.display = 'block';
            botonDetenerVideo.style.display = 'none';
        }

        const video = document.getElementById("video");
        const canvas = document.getElementById("canvas");
        const ctx = canvas.getContext("2d");
        const imgStream = document.getElementById("processedStream");
        
        // ===== CONEXI칍N WEBSOCKET (Socket.IO) =====

        // Me conecto por websocket al servidor flask
        const socket = io();
        console.log("Conectado al servidor via Socket.IO");
        
        // Recibir frames de video del dron
        socket.on('stream_frame', function(data) {
            console.log("Recibo frame por Socket.IO");
            document.getElementById('video-stream').src = 'data:image/jpeg;base64,' + data;
        });
        
        // Recibir telemetr칤a del dron
        socket.on('telemetry_info', function(data) {
            telemetry_info = data;

            // Actualizar posici칩n y direcci칩n del dron
            if (data.lat && data.lon) {
                updateDronePosition(data.lat, data.lon, data.heading || 0);
            }

            // Actualizar telemetr칤a en el UI
            const telemetriaDiv = document.getElementById('datos-telemetria');
            telemetriaDiv.innerHTML = `
                <p><strong>Altitud:</strong> ${data.alt}m</p>
                <p><strong>Velocidad:</strong> ${data.groundSpeed.toFixed(2)}m/s</p>
                <p><strong>Estado:</strong> ${data.state}</p>
            `;

            // Detectar si acabamos de aterrizar
            if ((previousDroneState === 'landing' || previousDroneState === 'returning') && 
                data.state === 'connected') {
                if (previousDroneState === 'landing') {
                    showLandedState('botonAterrizar');
                } else if (previousDroneState === 'returning') {
                    showLandedState('botonRTL');
                }
            } else {
                updateButtonStates(data.state);
            }

            if (data.state == "flying") {
                const botonDespegar = document.getElementById('botonDespegar');
                botonDespegar.classList.remove('boton-amarillo');
                botonDespegar.classList.add('boton-verde');
            }

            previousDroneState = data.state;
        });

        // Recibir eventos de video
        socket.on('video_error', function(errorMsg) {
            console.error(`Error en grabaci칩n: ${errorMsg}`);
            alert(`Error en grabaci칩n: ${errorMsg}`);
            document.getElementById('botonIniciarVideo').style.display = 'block';
            document.getElementById('botonDetenerVideo').style.display = 'none';
        });

        socket.on('flight_name_set', function(flightName) {
            currentFlightName = flightName;
            console.log(`Nombre del vuelo establecido: ${currentFlightName}`);
            const webcamContainer = document.getElementById('webcam-container');
            let flightNameDisplay = document.getElementById('flight-name-display');
            if (!flightNameDisplay) {
                flightNameDisplay = document.createElement('div');
                flightNameDisplay.id = 'flight-name-display';
                flightNameDisplay.style.position = 'absolute';
                flightNameDisplay.style.top = '50px';
                flightNameDisplay.style.left = '10px';
                flightNameDisplay.style.background = 'rgba(0,0,0,0.7)';
                flightNameDisplay.style.color = 'white';
                flightNameDisplay.style.padding = '5px 10px';
                flightNameDisplay.style.borderRadius = '5px';
                flightNameDisplay.style.zIndex = '1001';
                webcamContainer.appendChild(flightNameDisplay);
            }
            flightNameDisplay.textContent = `Vuelo: ${currentFlightName}`;
        });

        socket.on('foto_capturada', function(nombreFoto) {
            let ubicacion = currentFlightName ? `${currentFlightName}/${nombreFoto}` : nombreFoto;
            console.log(`Foto capturada: ${ubicacion}`);
        });

        socket.on('video_iniciado', function(nombreVideo) {
            let ubicacion = currentFlightName ? `${currentFlightName}/${nombreVideo}` : nombreVideo;
            console.log(`Grabaci칩n iniciada: ${ubicacion}`);
        });

        socket.on('video_detenido', function() {
            console.log("Grabaci칩n detenida");
        });

        // Funci칩n para actualizar el estado de todos los botones seg칰n el estado del dron
        function updateButtonStates(droneState) {
            const botonConectar = document.getElementById('botonConectar');
            const botonDespegar = document.getElementById('botonDespegar');
            const botonAterrizar = document.getElementById('botonAterrizar');
            const botonRTL = document.getElementById('botonRTL');

            // Resetear clases de todos los botones
            function resetButtonClasses(button) {
                button.classList.remove('boton-verde', 'boton-amarillo', 'boton-rojo');
            }

            switch (droneState) {
                case 'connected':
                    // Dron conectado pero en tierra
                    if (!despegando) {
                        botonDespegar.disabled = false;
                        botonDespegar.textContent = 'Despegar';
                        resetButtonClasses(botonDespegar);
                    }
                    
                    botonAterrizar.disabled = true;
                    botonAterrizar.textContent = 'Aterrizar';
                    resetButtonClasses(botonAterrizar);
                    
                    botonRTL.disabled = true;
                    botonRTL.textContent = 'RTL';
                    resetButtonClasses(botonRTL);
                    break;

                case 'arming':
                    break;
                    
                case 'takingOff':
                    break;

                case 'flying':
                    // Dron volando
                    despegando = false; // Resetear variable cuando est칠 volando
                    botonDespegar.disabled = true;
                    botonDespegar.textContent = 'Volando';
                    resetButtonClasses(botonDespegar);
                    botonDespegar.classList.add('boton-verde');
                    
                    botonAterrizar.disabled = false;
                    botonAterrizar.textContent = 'Aterrizar';
                    resetButtonClasses(botonAterrizar);
                    
                    botonRTL.disabled = false;
                    botonRTL.textContent = 'RTL';
                    resetButtonClasses(botonRTL);
                    break;

                case 'landing':
                    // Dron aterrizando
                    botonDespegar.disabled = true;
                    botonAterrizar.disabled = true;
                    botonAterrizar.textContent = 'Aterrizando...';
                    resetButtonClasses(botonAterrizar);
                    botonAterrizar.classList.add('boton-amarillo');
                    botonRTL.disabled = true;
                    break;

                case 'returning':
                    // Dron volviendo a base (RTL)
                    botonDespegar.disabled = true;
                    botonAterrizar.disabled = true;
                    botonRTL.disabled = true;
                    botonRTL.textContent = 'Volviendo a base...';
                    resetButtonClasses(botonRTL);
                    botonRTL.classList.add('boton-amarillo');
                    break;

                default:
                    // Estado desconocido o desconectado
                    botonDespegar.disabled = true;
                    botonDespegar.textContent = 'Despegar';
                    resetButtonClasses(botonDespegar);
                    
                    botonAterrizar.disabled = true;
                    botonAterrizar.textContent = 'Aterrizar';
                    resetButtonClasses(botonAterrizar);
                    
                    botonRTL.disabled = true;
                    botonRTL.textContent = 'RTL';
                    resetButtonClasses(botonRTL);
                    break;
            }
        }

        // Funci칩n para mostrar temporalmente estado "En Tierra"
        function showLandedState(buttonId) {
            const button = document.getElementById(buttonId);
            button.textContent = 'En Tierra';
            button.classList.remove('boton-amarillo');
            button.classList.add('boton-verde');
            
            // Despu칠s de 3 segundos, resetear al estado base
            setTimeout(() => {
                updateButtonStates('connected');
            }, 3000);
        }

        // Variable para trackear el estado anterior del dron
        let previousDroneState = null;
        
        // Variable para evitar sobrescribir estado manual de despegue
        let despegando = false;

        function conectarDron() {
            console.log("Voy a conectar");
            socket.emit('command', { action: 'connect' });
            const botonConectar = document.getElementById('botonConectar');
            botonConectar.classList.add('boton-verde');
        }

        function despegarDron() {
            const altura = document.getElementById('altura').value;
            if (altura) {
                socket.emit('command', { action: 'arm_takeOff', altura: String(altura) });
                
                despegando = true;
                const botonDespegar = document.getElementById('botonDespegar');
                botonDespegar.textContent = 'Despegando...';
                botonDespegar.classList.add('boton-amarillo');
                botonDespegar.disabled = true;
            } else {
                alert("Por favor, ingrese una altura v치lida.");
            }
        }

        // Funci칩n para despegar el dron mediante gesto usando MediaPipe
        function despegarDronDesdeGesto(altura) {
            const alturaInput = document.getElementById("altura");
            if (alturaInput) {
                alturaInput.value = altura;
                
                despegando = true;
                const botonDespegar = document.getElementById('botonDespegar');
                botonDespegar.textContent = 'Despegando...';
                botonDespegar.classList.add('boton-amarillo');
                botonDespegar.disabled = true;
                
                socket.emit('command', { action: 'arm_takeOff', altura: String(altura) });
            } else {
                alert("Por favor, ingrese una altura v치lida.");
            }
        }

        function aterrizarDron() {
            socket.emit('command', { action: 'Land' });
             
            const botonAterrizar = document.getElementById('botonAterrizar');
            botonAterrizar.textContent = 'Aterrizando...';
            botonAterrizar.classList.add('boton-amarillo');
            botonAterrizar.disabled = true;
        }

        function moverDron(direction) {
            socket.emit('command', { action: 'go', direction: direction });
        }

        function returnToLaunch() {
            socket.emit('command', { action: 'RTL' });
            
            const botonRTL = document.getElementById('botonRTL');
            botonRTL.textContent = 'Volviendo a base...';
            botonRTL.classList.add('boton-amarillo');
            botonRTL.disabled = true;
        }

        function mover_dron_a_coordenadas(lat, lng) {
            const mensaje = { lat: lat, lng: lng };
            console.log(`Enviando comando goto: ${JSON.stringify(mensaje)}`);
            socket.emit('command', { action: 'goto', lat: lat, lng: lng });
        }

        // Funci칩n para seguir una ruta de waypoints
        let is_following_route = false;
        function seguir_ruta_waypoints(waypoints) {
        try {
            // Marcamos que el dron est치 siguiendo una ruta
            is_following_route = true;

            // Enviamos la informaci칩n de la ruta
            const mensaje = JSON.stringify({
                "waypoints": waypoints
            });

            console.log(`Iniciando seguimiento de ruta con ${waypoints.length} waypoints`);

            return true;
            } catch (error) {
            console.error(`Error al iniciar seguimiento de ruta: ${error}`);
            is_following_route = false;
            return false;
            }
        }

        // Indico que no quiero ver el video del movil en la pantalla
        video.style.display = 'none';
        let cam;

        // Activo la c치mara frontal del m칩vil
        function frontCamera() {
        // Elijo la c치mara frontal
            cam = "user";
            const botonFront = document.getElementById('botonFront');
            botonFront.classList.add('boton-verde');

            startVideo();
        }

        // Activo la c치mara trasera del m칩vil (he desactivado esta opci칩n para que la atenci칩n se la lleve la c치mara frontal, pero funcionaria exactamente igual)
        function backCamera () {
        // Elijo la c치mara trasera
            const botonBack = document.getElementById('botonBack');
            botonBack.classList.add('boton-verde');

            cam = "environment";
            startVideo();
        }

        // Inicio el video del m칩vil
        function startVideo() {
        // Verificar si getUserMedia es soportado por el navegador
            if (navigator.mediaDevices.getUserMedia) {
                 // Aqui le indico la c치mara que quiero
                 navigator.mediaDevices.getUserMedia({
                     video: { facingMode: cam }
                 }).then(function(stream) {
                     // Asignar el stream al elemento de video
                     video.srcObject = stream;
                     sendFrames();

                 })
                   .catch(function(error) {
                        console.log("Error al acceder a la c치mara: ", error);
                   });
            } else {
                 alert("getUserMedia no est치 soportado por este navegador.");
            }
        }

        // Envio el video del m칩vil al servidor para que lo procese
        function sendFrames() {
            setInterval(() => {
                canvas.width = video.videoWidth;
                canvas.height = video.videoHeight;
                ctx.drawImage(video, 0, 0, canvas.width, canvas.height);
                let frame = canvas.toDataURL("image/jpeg"); // Convertir a base64
                socket.emit("frame_from_camera", frame); // Enviar frame al servidor
            }, 200); // 200ms es 5 FPS, 66ms es 15 FPS y 33ms es 30 FPS
        }

        // Recibir frames procesados del servidor y mostrarlos
        socket.on("processed_frame", function (data) {
            imgStream.src = data; // Mostrar el frame recibido
        });

        // Recibo despegar desde mediapipe
        socket.on('arm_takeOff', function(data) {
            console.log ("WebApp recibe despegar");
            despegarDronDesdeGesto(data);
        });

        // Recibo aterrizar desde mediapipe
        socket.on('Land', function() {
            console.log ("WebApp recibe aterrizar");
            aterrizarDron();
        });

        // Recibo mover o stop desde mediapipe
        socket.on('go', function(data) {
            console.log ("WebApp recibe go");
            moverDron(data);
        });

        // cuando me pidan los datos de telemetr칤a entrego los valores que tengo para esos datos
        function obtenerDatosTelemetria() {
        // La telemetr칤a ya se est치 recibiendo en el event listener de 'message'
        // Esta funci칩n devuelve los datos m치s recientes

            if (telemetry_info) {
                return {
                    estado: "success",
                    data: {
                        lat: telemetry_info.lat,
                        lon: telemetry_info.lon,
                        alt: telemetry_info.alt,
                        velocidad: telemetry_info.groundSpeed,
                        direccion: telemetry_info.heading,
                        estado: telemetry_info.state
                    }
                };
            } else {
                return {
                    estado: "fail",
                    message: "A칰n no hay datos de telemetr칤a"
                };
            }
        }
        
        // ===== CONTROL JOYSTICK (DISPOSITIVOS T츼CTILES) =====

        // JOYSTICK FLOTANTE - Variables globales
        // Variables globales del joystick
        let joystickActive = false;
        let joystickStartX, joystickStartY;
        let joystickContainer, joystickKnob, joystickArea;
        let joystickInterval = null;
        let joystickMaxDistance = 55; // Distancia m치xima fija

        // Inicializar referencias a elementos del joystick
        function initJoystick() {
            joystickArea = document.getElementById('joystick-area');
            joystickContainer = document.getElementById('joystick-container');
            joystickKnob = document.getElementById('joystick-knob');
        }

        // Funci칩n para mostrar el joystick en una posici칩n espec칤fica
        function showJoystick(x, y) {
            // En dispositivos t치ctiles, el joystick es fijo, solo resetear
            if (IS_TOUCH_DEVICE) {
                resetJoystickKnob();
                return;
            }
            
            // En dispositivos no t치ctiles, comportamiento original
            joystickContainer.style.left = (x - 90) + 'px';
            joystickContainer.style.top = (y - 90) + 'px';
            joystickContainer.style.display = 'block';
            resetJoystickKnob();
        }

        // Funci칩n para ocultar el joystick
        function hideJoystick() {
            joystickActive = false;
            if (joystickInterval) {
                clearInterval(joystickInterval);
                joystickInterval = null;
            }
            // Enviar comando de parada
            moverDron('Stop');
            
            // En dispositivos t치ctiles, solo resetear knob, no ocultar
            if (IS_TOUCH_DEVICE) {
                resetJoystickKnob();
                return;
            }
            
            // En dispositivos no t치ctiles, ocultar completamente
            joystickContainer.style.display = 'none';
        }

        // Funci칩n para resetear la posici칩n del knob al centro
        function resetJoystickKnob() {
            joystickKnob.style.transform = 'translate(-50%, -50%)';
        }

        // Funci칩n para actualizar la posici칩n del knob
        function updateJoystickKnob(deltaX, deltaY) {
            const distance = Math.sqrt(deltaX * deltaX + deltaY * deltaY);
            
            if (distance <= joystickMaxDistance) {
                joystickKnob.style.transform = `translate(calc(-50% + ${deltaX}px), calc(-50% + ${deltaY}px))`;
            } else {
                // Limitar el knob al borde del joystick
                const angle = Math.atan2(deltaY, deltaX);
                const limitedX = Math.cos(angle) * joystickMaxDistance;
                const limitedY = Math.sin(angle) * joystickMaxDistance;
                joystickKnob.style.transform = `translate(calc(-50% + ${limitedX}px), calc(-50% + ${limitedY}px))`;
                deltaX = limitedX;
                deltaY = limitedY;
            }
            
            return { x: deltaX, y: deltaY };
        }

        // Funci칩n para convertir la posici칩n del joystick a comando de direcci칩n
        function joystickToDirection(deltaX, deltaY) {

            const distance = Math.sqrt(deltaX * deltaX + deltaY * deltaY);
            
            const threshold = 15;
                        
            if (distance < threshold) {
                return 'Stop';
            }
            
            // Calcular 치ngulo (0춿 = Este, 90춿 = Norte, 180춿 = Oeste, 270춿 = Sur)
            let angle = Math.atan2(-deltaY, deltaX) * 180 / Math.PI; // -deltaY porque Y crece hacia abajo
            if (angle < 0) angle += 360;
            
            console.log(`Debug angle: ${angle.toFixed(1)}춿`);
            
            // Convertir 치ngulo a direcci칩n cardinal/intercardinal
            if (angle >= 337.5 || angle < 22.5) return 'East';
            else if (angle >= 22.5 && angle < 67.5) return 'NorthEast';
            else if (angle >= 67.5 && angle < 112.5) return 'North';
            else if (angle >= 112.5 && angle < 157.5) return 'NorthWest';
            else if (angle >= 157.5 && angle < 202.5) return 'West';
            else if (angle >= 202.5 && angle < 247.5) return 'SouthWest';
            else if (angle >= 247.5 && angle < 292.5) return 'South';
            else if (angle >= 292.5 && angle < 337.5) return 'SouthEast';
            
            return 'Stop';
        }

        // Variable para almacenar la 칰ltima direcci칩n enviada
        let lastDirection = 'Stop';

        // Funci칩n para enviar comandos del joystick al dron
        function sendJoystickCommand(deltaX, deltaY) {
            const direction = joystickToDirection(deltaX, deltaY);
            
            // Debug: mostrar valores
            console.log(`Debug Joystick - deltaX: ${deltaX.toFixed(1)}, deltaY: ${deltaY.toFixed(1)}, direction: ${direction}`);
            
            // Solo enviar comando si la direcci칩n ha cambiado
            if (direction !== lastDirection) {
                console.log(`Joystick: ${direction} (deltaX: ${deltaX.toFixed(1)}, deltaY: ${deltaY.toFixed(1)})`);
                moverDron(direction);
                lastDirection = direction;
            }
        }

        // Variables adicionales para tracking t치ctil
        let currentTouchX = 0;
        let currentTouchY = 0;

        // Event listeners para eventos t치ctiles (m칩viles/tablets)
        function setupJoystickTouchEvents() {
            joystickArea.addEventListener('touchstart', function(e) {
                e.preventDefault();
                const touch = e.touches[0];
                const rect = joystickArea.getBoundingClientRect();
                const x = touch.clientX - rect.left;
                const y = touch.clientY - rect.top;
                
                joystickActive = true;
                
                // Coordenadas fijas del joystick (solo dispositivos t치ctiles llegan aqu칤)
                joystickStartX = 100 + 60; // left + radius
                joystickStartY = window.innerHeight - 100 - 60; // height - bottom - radius
                
                showJoystick(x, y);
                
                console.log('Touch START:', {x, y, joystickStartX, joystickStartY, isTouch: IS_TOUCH_DEVICE});
                
                // Iniciar env칤o peri칩dico de comandos
                joystickInterval = setInterval(() => {
                    if (joystickActive && currentTouchX !== 0 && currentTouchY !== 0) {
                        const deltaX = currentTouchX - joystickStartX;
                        const deltaY = currentTouchY - joystickStartY;
                        const limited = updateJoystickKnob(deltaX, deltaY);
                        sendJoystickCommand(limited.x, limited.y);
                    }
                }, 150); // Enviar comandos cada 150ms
            });

            joystickArea.addEventListener('touchmove', function(e) {
                e.preventDefault();
                if (!joystickActive) return;
                
                const touch = e.touches[0];
                
                // Usar coordenadas globales (solo dispositivos t치ctiles llegan aqu칤)
                currentTouchX = touch.clientX;
                currentTouchY = touch.clientY;
                
                const deltaX = currentTouchX - joystickStartX;
                const deltaY = currentTouchY - joystickStartY;
                
                console.log('Touch MOVE:', {currentTouchX, currentTouchY, deltaX, deltaY});
                
                // Actualizar posici칩n del knob inmediatamente
                const limited = updateJoystickKnob(deltaX, deltaY);
            });

            joystickArea.addEventListener('touchend', function(e) {
                e.preventDefault();
                console.log('Touch END');
                // Resetear las coordenadas t치ctiles
                currentTouchX = 0;
                currentTouchY = 0;
                hideJoystick();
                lastDirection = 'Stop';
            });
        }

        // Event listeners para eventos de mouse (para testing en desktop)
        function setupJoystickMouseEvents() {
            joystickArea.addEventListener('mousedown', function(e) {
                e.preventDefault();
                const rect = joystickArea.getBoundingClientRect();
                const x = e.clientX - rect.left;
                const y = e.clientY - rect.top;
                
                joystickActive = true;
                joystickStartX = x;
                joystickStartY = y;
                showJoystick(x, y);
                
                // Iniciar env칤o peri칩dico de comandos
                joystickInterval = setInterval(() => {
                    if (joystickActive) {
                        // Usar las coordenadas actuales del mouse
                        const currentRect = joystickArea.getBoundingClientRect();
                        // Nota: para mouse necesitamos trackear la posici칩n actual
                    }
                }, 150);
            });

            joystickArea.addEventListener('mousemove', function(e) {
                if (!joystickActive) return;
                
                const rect = joystickArea.getBoundingClientRect();
                const deltaX = (e.clientX - rect.left) - joystickStartX;
                const deltaY = (e.clientY - rect.top) - joystickStartY;
                
                const limited = updateJoystickKnob(deltaX, deltaY);
                sendJoystickCommand(limited.x, limited.y);
            });

            joystickArea.addEventListener('mouseup', function(e) {
                e.preventDefault();
                hideJoystick();
                lastDirection = 'Stop';
            });

            // Manejar cuando el mouse sale del 치rea
            joystickArea.addEventListener('mouseleave', function(e) {
                if (joystickActive) {
                    hideJoystick();
                    lastDirection = 'Stop';
                }
            });
        }
        
        // ===== INICIALIZACI칍N DE LA APLICACI칍N =====

        // Inicializar el joystick cuando se carga la p치gina
        document.addEventListener('DOMContentLoaded', function() {
            // Configurar interfaz seg칰n tipo de dispositivo
            setupDeviceSpecificUI();
            
            // Inicializar funcionalidad del joystick
            initJoystick();
            setupJoystickTouchEvents();
            setupJoystickMouseEvents();
        });
        
        // Funci칩n para configurar la UI seg칰n el tipo de dispositivo
        function setupDeviceSpecificUI() {
            const joystickContainer = document.getElementById('joystick-container');
            const joystickArea = document.getElementById('joystick-area');
            const navegacion = document.getElementById('navegacion');
            const toggleNavBtn = document.getElementById('toggleNavegacion');
            
            if (IS_TOUCH_DEVICE) {
                // Dispositivo t치ctil: mostrar joystick fijo, ocultar cruceta
                if (joystickContainer) {
                    joystickContainer.classList.add('touch-device');
                }
                if (joystickArea) {
                    joystickArea.classList.remove('non-touch-hidden');
                }
                if (navegacion) {
                    navegacion.classList.add('touch-hidden');
                }
                if (toggleNavBtn) {
                    toggleNavBtn.style.display = 'none';
                }
                console.log('Configurado para dispositivo t치ctil: Joystick visible, cruceta oculta');
            } else {
                // Dispositivo no t치ctil: ocultar joystick completamente, mostrar cruceta
                if (joystickContainer) {
                    joystickContainer.classList.remove('touch-device');
                }
                if (joystickArea) {
                    joystickArea.classList.add('non-touch-hidden');
                }
                if (navegacion) {
                    navegacion.classList.remove('touch-hidden');
                }
                console.log('Configurado para dispositivo no t치ctil: Cruceta visible, joystick completamente oculto');
            }
        }
        
    </script>
</body>
</html>
