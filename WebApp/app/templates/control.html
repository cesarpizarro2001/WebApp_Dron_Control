<!--Este es el fichero que enviará el servidor web al navegador cuando éste se conecte a la web-->

<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no, maximum-scale=1.0, minimum-scale=1.0">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <title>Web App</title>
    
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.3/dist/leaflet.css" />
    <!--    Necesito estos scripts para trabajar con websockets (Socket.IO)-->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/socket.io/4.0.1/socket.io.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/js/bootstrap.bundle.min.js"></script>
    <script>
        // Detectar si es un dispositivo táctil
        function isTouchDevice() {
            return (('ontouchstart' in window) ||
                   (navigator.maxTouchPoints > 0) ||
                   (navigator.msMaxTouchPoints > 0));
        }
        
        // Variable global para saber si es táctil
        const IS_TOUCH_DEVICE = isTouchDevice();
        console.log('Dispositivo táctil detectado:', IS_TOUCH_DEVICE);
    </script>
</head>
<style>
        /* === ESTILOS BÁSICOS === */
        html, body { 
            margin: 0; 
            padding: 0;
            height: 100%;
            width: 100%;
            overflow: hidden;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
        }
        
        /* === CONTENEDORES PRINCIPALES === */
        #map { 
            height: 100%; 
            width: 100%; 
        }
        
        #webcam-container {
            height: 100vh;
            width: 100%;
            display: none;
            background-color: black;
            justify-content: center;
            align-items: center;
        }
        
        #webcam-video {
            max-width: 100%;
            max-height: 100%;
            object-fit: contain;
        }
        
        /* === TELEMETRÍA === */
        #datos-telemetria {
            position: absolute;
            top: 20px;
            left: 60px;
            background: rgba(255, 255, 255, 0.5);
            padding: 8px 12px;
            border-radius: 10px;
            box-shadow: 0 3px 10px rgba(0, 0, 0, 0.15);
            z-index: 1000;
            display: flex;
            flex-direction: column;
            gap: 5px;
            font-size: 13px;
            backdrop-filter: blur(10px);
        }

        #datos-telemetria > span {
            display: flex;
            align-items: center;
            white-space: nowrap;
        }
        
        .dato {
            font-weight: 700;
            color: #333;
            margin-left: 6px;
            font-size: 15px;
        }
        
        #datos-telemetria strong {
            color: #555;
            font-weight: 600;
        }
        
        #datos-telemetria strong::before {
            content: '•';
            color: #4CAF50;
            font-size: 16px;
            margin-right: 5px;
        }
        
        /* === CONTROLES === */
        /* Barra superior de controles principales */
        .top-controls {
            position: absolute;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            gap: 8px;
            z-index: 1000;
            background: rgba(255, 255, 255, 0.1);
            padding: 8px 12px;
            border-radius: 10px;
            box-shadow: 0 3px 10px rgba(0, 0, 0, 0.15);
            backdrop-filter: blur(10px);
        }

        .top-controls button {
            padding: 6px 14px;
            font-size: 12px;
            font-weight: 600;
            border: none;
            border-radius: 6px;
            cursor: pointer;
            transition: all 0.2s ease;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
        }

        .top-controls button:hover {
            transform: translateY(-1px);
            box-shadow: 0 3px 8px rgba(0, 0, 0, 0.2);
        }

        .top-controls button:active {
            transform: translateY(0);
        }

        .top-controls input {
            padding: 6px 10px;
            border: 2px solid #e0e0e0;
            border-radius: 6px;
            font-size: 12px;
            width: 80px;
            outline: none;
            transition: border-color 0.2s ease;
        }

        .top-controls input:focus {
            border-color: #2196F3;
        }

        /* Dropdown de funcionalidades */
        .features-dropdown {
            position: absolute;
            top: 20px;
            right: 20px;
            z-index: 1000;
        }

        .features-dropdown .dropdown-toggle {
            padding: 8px 14px;
            font-size: 12px;
        }

        .features-dropdown .dropdown-menu {
            min-width: 180px;
        }

        .features-dropdown .dropdown-menu button {
            padding: 8px 12px;
            font-size: 12px;
        }

        .modes-dropdown {
            position: absolute;
            bottom: 80px;
            right: 20px;
            z-index: 1000;
        }

        .modes-dropdown .dropdown-menu {
            bottom: 100%;
            top: auto;
            border-radius: 12px;
            margin-bottom: 0;
        }

        .modes-dropdown .dropdown-toggle {
            border-radius: 12px;
        }

        .modes-dropdown .dropdown-toggle.active {
            border-radius: 12px;
        }

        .dropdown-toggle {
            background: rgba(255, 255, 255, 0.95);
            border: none;
            padding: 12px 20px;
            border-radius: 12px;
            cursor: pointer;
            font-size: 14px;
            font-weight: 600;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
            display: flex;
            align-items: center;
            gap: 8px;
            transition: all 0.2s ease;
            backdrop-filter: blur(10px);
        }

        .dropdown-toggle.active {
            border-radius: 12px;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
        }

        .dropdown-toggle:hover:not(.active) {
            transform: translateY(-2px);
            box-shadow: 0 4px 16px rgba(0, 0, 0, 0.2);
        }

        .dropdown-toggle::after {
            content: '▼';
            font-size: 10px;
            transition: transform 0.2s ease;
        }

        .dropdown-toggle.active::after {
            transform: rotate(180deg);
        }

        .dropdown-menu {
            position: absolute;
            top: 100%;
            right: 0;
            background: rgba(255, 255, 255, 0.95);
            border-radius: 12px;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
            padding: 8px;
            min-width: 200px;
            display: none;
            backdrop-filter: blur(10px);
            margin-top: 0;
        }

        .dropdown-menu.show {
            display: block;
            animation: slideDown 0.2s ease;
        }

        @keyframes slideDown {
            from {
                opacity: 0;
                transform: translateY(-10px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        @keyframes slideUp {
            from {
                opacity: 0;
                transform: translateY(10px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        .modes-dropdown .dropdown-menu.show {
            animation: slideUp 0.2s ease;
        }

        .dropdown-menu button {
            width: 100%;
            padding: 10px 15px;
            margin: 3px 0;
            border: none;
            border-radius: 8px;
            font-size: 13px;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.2s ease;
            text-align: left;
        }

        .dropdown-menu button:hover {
            transform: translateX(5px);
        }

        /* Botón de seguimiento estilo Google Maps */
        .follow-button {
            position: absolute;
            bottom: 20px;
            right: 20px;
            width: 50px;
            height: 50px;
            background: white;
            border: none;
            border-radius: 50%;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 1000;
        }

        .follow-button:active {
            transform: scale(0.95);
        }

        .follow-button.active {
            background: #4CAF50;
            box-shadow: 0 6px 16px rgba(76, 175, 80, 0.4);
        }

        .follow-button svg {
            width: 28px;
            height: 28px;
            fill: #666;
            transition: fill 0.2s ease;
        }

        .follow-button.active svg {
            fill: white;
        }

        .controls {
            display: none; /* Ocultamos el viejo contenedor */
        }
        
        /* === BOTONES COLOREADOS === */
        .boton-verde { background-color: #4CAF50; color: white; }
        .boton-amarillo { background-color: #FFD700; color: black; }
        .boton-rojo { background-color: #f44336; color: white; }
        .boton-azul { background-color: #2196F3; color: white; }
        
        /* === INDICADOR MODO SEGUIMIENTO === */
        .follow-mode-indicator {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 60px;
            height: 60px;
            border: 3px solid #4CAF50;
            border-radius: 50%;
            background: rgba(76, 175, 80, 0.1);
            pointer-events: none;
            z-index: 1001;
            display: none;
        }
        
        @keyframes pulse-follow {
            0% { transform: translate(-50%, -50%) scale(1); opacity: 0.7; }
            50% { transform: translate(-50%, -50%) scale(1.1); opacity: 0.3; }
            100% { transform: translate(-50%, -50%) scale(1); opacity: 0.7; }
        }
        
        /* === JOYSTICK === */
        .joystick-area {
            position: absolute;
            left: 0;
            top: 0;
            width: 50%;
            height: 100vh;
            z-index: 500;
            pointer-events: auto;
            touch-action: none;
        }
        
        .joystick-container {
            position: fixed;
            bottom: 100px;
            left: 100px;
            width: 120px;
            height: 120px;
            background: rgba(255, 255, 255, 0.2);
            border: 3px solid rgba(255, 255, 255, 0.4);
            border-radius: 50%;
            display: none;
            z-index: 501;
            pointer-events: none;
            transition: opacity 0.2s ease;
        }
        
        .joystick-knob {
            position: absolute;
            width: 50px;
            height: 50px;
            background: rgba(66, 165, 245, 0.7);
            border: 2px solid rgba(33, 150, 243, 0.8);
            border-radius: 50%;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            pointer-events: none;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.2);
            transition: transform 0.1s ease;
        }
        
        .joystick-center-dot {
            position: absolute;
            width: 4px;
            height: 4px;
            background: rgba(255, 255, 255, 0.8);
            border-radius: 50%;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            pointer-events: none;
        }
        
        /* === CLASES DE VISIBILIDAD SEGÚN DISPOSITIVO === */
        /* Mostrar joystick solo en dispositivos táctiles */
        .joystick-container.touch-device {
            display: block;
            opacity: 0.8;
        }

        /* === GRID DE NAVEGACIÓN === */
        .navigation-grid {
            position: absolute;
            bottom: 20px;
            left: 20px;
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 8px;
            background: rgba(255, 255, 255, 0.95);
            padding: 12px;
            border-radius: 12px;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
            z-index: 1000;
            backdrop-filter: blur(10px);
        }

        .nav-btn {
            width: 50px;
            height: 50px;
            border: none;
            border-radius: 8px;
            background: linear-gradient(135deg, #2196F3, #1976D2);
            color: white;
            font-weight: 600;
            font-size: 13px;
            cursor: pointer;
            transition: all 0.2s ease;
            box-shadow: 0 2px 6px rgba(0, 0, 0, 0.15);
        }

        .nav-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 10px rgba(33, 150, 243, 0.4);
        }

        .nav-btn:active {
            transform: translateY(0);
        }

        .nav-stop {
            background: linear-gradient(135deg, #FF9800, #F57C00);
            font-size: 18px;
        }

        .nav-stop:hover {
            box-shadow: 0 4px 10px rgba(255, 152, 0, 0.4);
        }
        
        /* Ocultar cruceta en dispositivos táctiles */
        .navigation-grid.touch-hidden {
            display: none !important;
        }
        
        /* Ocultar joystick completamente en dispositivos no táctiles */
        .joystick-area.non-touch-hidden {
            display: none !important;
        }
        
        /* === UTILIDADES === */
        .direction-arrow { 
            pointer-events: none; 
        }
        
        /* Prevenir selección de texto en elementos táctiles */
        .joystick-area, .joystick-container, .joystick-knob {
            -webkit-user-select: none;
            -moz-user-select: none;
            -ms-user-select: none;
            user-select: none;
            -webkit-touch-callout: none;
            -webkit-tap-highlight-color: transparent;
        }
        
        /* === CONTROL POR VOZ === */
        #voice-control-btn {
            position: fixed;
            bottom: 30px;
            left: 50%;
            transform: translateX(-50%);
            z-index: 2000;
            
            /* Estado normal */
            min-width: 140px;
            height: 55px;
            padding: 0 20px;
            border-radius: 28px;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            border: none;
            box-shadow: 0 6px 25px rgba(102, 126, 234, 0.5),
                        0 0 0 0 rgba(102, 126, 234, 0);
            color: white;
            font-size: 14px;
            font-weight: 700;
            letter-spacing: 0.5px;
            cursor: pointer;
            transition: all 0.4s cubic-bezier(0.68, -0.55, 0.265, 1.55);
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 10px;
            backdrop-filter: blur(10px);
        }
        
        #voice-control-btn::before {
            content: '';
            position: absolute;
            inset: -3px;
            border-radius: 28px;
            padding: 3px;
            background: linear-gradient(135deg, rgba(255,255,255,0.3), rgba(255,255,255,0.1));
            -webkit-mask: linear-gradient(#fff 0 0) content-box, linear-gradient(#fff 0 0);
            -webkit-mask-composite: xor;
            mask-composite: exclude;
            pointer-events: none;
            opacity: 0;
            transition: opacity 0.3s ease;
        }
        
        #voice-control-btn:hover:not(.listening):not(.processing)::before {
            opacity: 1;
        }
        
        #voice-control-btn:hover:not(.listening):not(.processing) {
            transform: translateX(-50%) translateY(-5px) scale(1.05);
            box-shadow: 0 10px 35px rgba(102, 126, 234, 0.6),
                        0 0 0 8px rgba(102, 126, 234, 0.1);
        }
        
        #voice-control-btn.listening {
            background: linear-gradient(135deg, #ff6b6b 0%, #ee5a6f 50%, #c44569 100%);
            animation: pulse-voice 1.5s ease-in-out infinite;
            box-shadow: 0 8px 30px rgba(255, 68, 68, 0.6),
                        0 0 0 0 rgba(255, 68, 68, 0.7);
        }
        
        #voice-control-btn.processing {
            min-width: 280px;
            background: linear-gradient(135deg, #56ab2f 0%, #a8e063 100%);
            box-shadow: 0 6px 25px rgba(76, 175, 80, 0.5),
                        0 0 0 8px rgba(76, 175, 80, 0.1);
        }
        
        #voice-control-btn.error {
            background: linear-gradient(135deg, #ff9966 0%, #ff5e62 100%);
            animation: shake 0.5s ease-in-out;
            box-shadow: 0 8px 30px rgba(255, 94, 98, 0.5);
        }
        
        @keyframes pulse-voice {
            0%, 100% { 
                box-shadow: 0 8px 30px rgba(255, 68, 68, 0.6),
                            0 0 0 0 rgba(255, 68, 68, 0.7);
                transform: translateX(-50%) scale(1);
            }
            50% { 
                box-shadow: 0 12px 40px rgba(255, 68, 68, 0.8),
                            0 0 0 20px rgba(255, 68, 68, 0);
                transform: translateX(-50%) scale(1.05);
            }
        }
        
        @keyframes shake {
            0%, 100% { transform: translateX(-50%) translateX(0); }
            10%, 30%, 50%, 70%, 90% { transform: translateX(-50%) translateX(-8px); }
            20%, 40%, 60%, 80% { transform: translateX(-50%) translateX(8px); }
        }
        
        .mic-icon {
            font-size: 24px;
            transition: all 0.3s ease;
            filter: drop-shadow(0 2px 4px rgba(0,0,0,0.2));
        }
        
        #voice-control-btn.listening .mic-icon {
            animation: mic-pulse 0.8s ease-in-out infinite;
        }
        
        @keyframes mic-pulse {
            0%, 100% { transform: scale(1); }
            50% { transform: scale(1.2); }
        }
        
        .voice-text {
            font-size: 16px;
            font-weight: 700;
            white-space: nowrap;
            text-shadow: 0 2px 4px rgba(0,0,0,0.2);
            letter-spacing: 1px;
        }
        
        #voice-control-btn.processing .voice-text {
            font-size: 14px;
            font-weight: 600;
            letter-spacing: 0.5px;
        }
    </style>
<body>
    <!-- Barra superior de controles principales -->
    <div class="top-controls">
        <input type="number" id="altura" placeholder="Altura (m)" />
        <button id="botonConectar" onclick="conectarDron()">Conectar</button>
        <button id="botonDespegar" onclick="despegarDron()">Despegar</button>
        <button id="botonAterrizar" onclick="aterrizarDron()">Aterrizar</button>
        <button id="botonRTL" onclick="returnToLaunch()">RTL</button>
    </div>

    <!-- Dropdown de funcionalidades -->
    <div class="features-dropdown">
        <button class="dropdown-toggle" onclick="toggleDropdown('dropdownMenu')">
            ⚙️ Funcionalidades
        </button>
        <div class="dropdown-menu" id="dropdownMenu">
            <button id="botonRuta" class="boton-azul" onclick="toggleRutaMode(); closeAllDropdowns()">📍 Crear Ruta</button>
            <button id="botonImagenDron" class="boton-azul" onclick="toggleWebcamView(); closeAllDropdowns()">📷 Cámara Dron</button>
            <button id="botonCapturarFoto" class="boton-azul" onclick="capturarFoto(); closeAllDropdowns()">📸 Hacer Foto</button>
            <button id="botonIniciarVideo" class="boton-azul" onclick="iniciarGrabacion(); closeAllDropdowns()">🎥 Hacer Video</button>
            <button id="botonDetenerVideo" class="boton-rojo" style="display:none;" onclick="detenerGrabacion(); closeAllDropdowns()">⏹️ Detener Video</button>
            <button id="botonCamaraMovil" class="boton-azul" onclick="abrirVentanaCamara(); closeAllDropdowns()">📱 Cámara Móvil</button>
            <button id="toggleNavegacion" class="boton-azul" onclick="toggleNavegacion(); closeAllDropdowns()">🧭 Ocultar Nav.</button>
        </div>
    </div>

    <!-- Dropdown de modos -->
    <div class="modes-dropdown">
        <button class="dropdown-toggle" onclick="toggleDropdown('modesMenu')">
            🎮 Modos
        </button>
        <div class="dropdown-menu" id="modesMenu">
            <button id="botonModoPiloto" class="boton-azul" onclick="irAModoPiloto(); closeAllDropdowns()">🎮 Modo Piloto</button>
            <button class="boton-azul" style="opacity: 0.5; cursor: not-allowed;" disabled>📱 Control Movimiento<br><small style="font-size: 10px;">(Próximamente)</small></button>
        </div>
    </div>

    <!-- Botón de seguimiento estilo Google Maps -->
    <button class="follow-button" id="followButton" onclick="toggleFollowDrone()" title="Seguir dron">
        <svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
            <path id="followIcon" d="M12 8c-2.21 0-4 1.79-4 4s1.79 4 4 4 4-1.79 4-4-1.79-4-4-4zm8.94 3c-.46-4.17-3.77-7.48-7.94-7.94V1h-2v2.06C6.83 3.52 3.52 6.83 3.06 11H1v2h2.06c.46 4.17 3.77 7.48 7.94 7.94V23h2v-2.06c4.17-.46 7.48-3.77 7.94-7.94H23v-2h-2.06zM12 19c-3.87 0-7-3.13-7-7s3.13-7 7-7 7 3.13 7 7-3.13 7-7 7z"/>
        </svg>
    </button>

    <!-- Grid de navegación mejorado -->
    <div id="navegacion" class="navigation-grid">
        <button onclick="moverDron('NorthWest')" class="nav-btn">NW</button>
        <button onclick="moverDron('North')" class="nav-btn">N</button>
        <button onclick="moverDron('NorthEast')" class="nav-btn">NE</button>
        <button onclick="moverDron('West')" class="nav-btn">W</button>
        <button onclick="moverDron('Stop')" class="nav-btn nav-stop">⏹</button>
        <button onclick="moverDron('East')" class="nav-btn">E</button>
        <button onclick="moverDron('SouthWest')" class="nav-btn">SW</button>
        <button onclick="moverDron('South')" class="nav-btn">S</button>
        <button onclick="moverDron('SouthEast')" class="nav-btn">SE</button>
    </div>

    <div id="datos-telemetria">
        <span><strong>Altitud:</strong> <span class="dato" id="altitud">0m</span></span>
        <span><strong>Velocidad:</strong> <span class="dato" id="velocidad">0m/s</span></span>
        <span><strong>Estado:</strong> <span class="dato" id="estado">Desconocido</span></span>
    </div>

    <div id="webcam-container" style="display: none; margin-top: 20px; text-align: center;">
        <h3>Video por WebSockets</h3>
        <img id='video-stream' style='width:100%; max-width:600px;'>
    </div>

    <div id="camara-container" style="display: none; margin-top: 20px; text-align: center;">
        <h3>Camara</h3>
        <div id="button-container">
            <button id="botonFront" class="boton" onclick="frontCamera()">Cámara frontal</button>
            <!-- <button id="botonBack" class="boton" onclick="backCamera() disabled">Cámara trasera</button> (Opción de usar también la cámara trasera)-->
        </div>
        <video id="video" autoplay playsinline></video>
        <canvas id="canvas" style="display:none;"></canvas>
        <img id="processedStream" alt="Video Procesado">
    </div>

    <div id="map"></div>

    <!-- Control por voz -->
    <button id="voice-control-btn" onclick="iniciarControlVoz()">
        <span class="mic-icon">🎤</span>
        <span class="voice-text">VOZ</span>
    </button>

    <!-- Indicador visual del modo seguimiento -->
    <div id="follow-indicator" class="follow-mode-indicator"></div>

    <!-- Área del joystick flotante (mitad izquierda de la pantalla) -->
    <div class="joystick-area" id="joystick-area">
        <div class="joystick-container" id="joystick-container">
            <div class="joystick-center-dot"></div>
            <div class="joystick-knob" id="joystick-knob"></div>
        </div>
    </div>

<script src="https://unpkg.com/leaflet@1.9.3/dist/leaflet.js"></script>
<script>
        // Inicializar el mapa
        // ===== VARIABLES GLOBALES =====
        
        // Variables del mapa y posicionamiento
        var map = L.map('map').setView([41.27624, 1.98838], 20);
        L.tileLayer("https://mt1.google.com/vt/lyrs=s&x={x}&y={y}&z={z}", {
            maxZoom: 20
        }).addTo(map);

        // Variables globales para el seguimiento del dron
        let currentPos = [41.27624, 1.98838];
        let droneMarker = L.marker(currentPos, {
            icon: L.icon({
                iconUrl: 'static/icono_dron.png',
                iconSize: [30, 30],
                iconAnchor: [15, 15] // Centrar el icono
            }),
            zIndexOffset: 1000 // Asegurar que esté encima de otros elementos
        }).addTo(map);

        let currentFlightName = null;
        // Variables para la funcionalidad de ruta
        let rutaMode = false;
        let waypoints = [];
        let waypointMarkers = [];
        let siguiendoRuta = false;
        let rutaPolyline = L.polyline([], { color: 'black', weight: 3 }).addTo(map);
        let telemetry_info = null;
        
        // Variables para el seguimiento del dron
        let followDrone = false;
        let droneFollowButton = null;
        
        // ===== ICONOS Y MARCADORES =====

        // Función para manejar la orientación del dron
        function createArrowSVG(angle) {
        return `
        <svg width="300" height="300" viewBox="-150 -150 300 300" xmlns="http://www.w3.org/2000/svg">
            <g transform="rotate(${angle} 0 0)">
                <!-- Línea roja larga de dirección -->
                <line x1="0" y1="0" x2="0" y2="-140" stroke="red" stroke-width="3"/>
            </g>
        </svg>
        `;
        }

        // Función para crear el SVG del marcador de waypoint en forma de pin
        function createWaypointPinSVG(number, color = "#FFC107") {
            return `
                <svg width="30" height="45" viewBox="0 0 40 60" xmlns="http://www.w3.org/2000/svg">
                    <path d="M20 0C9 0 0 9 0 20C0 35 20 60 20 60C20 60 40 35 40 20C40 9 31 0 20 0Z" fill="${color}" stroke="#000" stroke-width="1"/>
                    <circle cx="20" cy="20" r="10" fill="white"/>
                    <text x="20" y="24" font-family="Arial" font-size="12" font-weight="bold" text-anchor="middle">${number}</text>
                </svg>
            `;
        }

        var DirectionArrow = L.Icon.extend({
            options: {
                iconSize: [300, 300],
                iconAnchor: [150, 150]
            }
        });

        // Definir el icono de waypoint personalizado
        var WaypointIcon = L.Icon.extend({
            options: {
                iconSize: [30, 45],
                iconAnchor: [15, 45],  // Punto de anclaje en la punta inferior del pin
                popupAnchor: [0, -45]  // Punto de anclaje para popups
            }
        });

        let directionArrow = L.marker(currentPos, {
            icon: new DirectionArrow({
                iconUrl: 'data:image/svg+xml;charset=utf-8,' + encodeURIComponent(createArrowSVG(0))
            })
        }).addTo(map);
        
        // ===== FUNCIONES DE MAPAS Y NAVEGACIÓN =====

        // Función para actualizar la posición del dron
        function updateDronePosition(lat, lon, heading) {
            const newPos = [lat, lon];
            
            // Siempre actualizar la posición real del dron
            droneMarker.setLatLng(newPos);
            directionArrow.setLatLng(newPos);
            
            // Si está en modo seguimiento, mover el mapa para mantener el dron centrado
            if (followDrone) {
                map.setView(newPos, map.getZoom(), {animate: true, duration: 0.3});
            }
            
            // Actualizar la dirección de la flecha
            directionArrow.setIcon(new DirectionArrow({
                iconUrl: 'data:image/svg+xml;charset=utf-8,' + encodeURIComponent(createArrowSVG(heading))
            }));

            currentPos = newPos;

            // Comprobar si está siguiendo una ruta y verificar si ha alcanzado un waypoint
            if (siguiendoRuta && waypoints.length > 0) {
                checkWaypointReached();
            }
        }

        // Función de Waypoint alcanzado
        function checkWaypointReached() {
            // Si no hay waypoints, no hay nada que verificar
            if (waypoints.length === 0) return;

            // Obtener el primer waypoint (el próximo destino)
            const nextWaypoint = waypoints[0];

            // Calcular la distancia entre el dron y el waypoint
            const droneLatLng = L.latLng(currentPos[0], currentPos[1]);
            const waypointLatLng = L.latLng(nextWaypoint.lat, nextWaypoint.lng);
            const distance = droneLatLng.distanceTo(waypointLatLng);

            // Si el dron está a menos de 3 metros del waypoint, consideramos que ha llegado
            if (distance < 3) {
                // Eliminar el waypoint alcanzado
                waypoints.shift();

                // Eliminar el marcador del waypoint
                if (waypointMarkers.length > 0) {
                    map.removeLayer(waypointMarkers[0]);
                    waypointMarkers.shift();
                }

                // Si quedan más waypoints, ir al siguiente
                if (waypoints.length > 0) {
                    const nextWaypoint = waypoints[0];
                    moverDronAWaypoint(nextWaypoint);
                } else {
                    // Si no quedan más waypoints, terminar la ruta
                    finalizarRuta();
                }
            }
        }

        // Función que indica fin de la ruta
        function finalizarRuta() {
            siguiendoRuta = false;

            // Limpiar la línea de la ruta
            rutaPolyline.setLatLngs([]);

            // Cambiar el botón de vuelta a "Crear Ruta"
            const botonRuta = document.getElementById('botonRuta');
            botonRuta.textContent = "Crear Ruta";
            botonRuta.classList.remove('boton-rojo');
            botonRuta.classList.add('boton-azul');

            // Habilitar los otros botones
            document.getElementById('botonConectar').disabled = false;
            document.getElementById('botonDespegar').disabled = false;


            waypoints = [];
            waypointMarkers.forEach(m => map.removeLayer(m));
            waypointMarkers = [];
            rutaPolyline.setLatLngs([]);  // <-- Esta línea asegura borrar la línea negra

        }

        // Manejar clicks en el mapa
        map.on('click', function(e) {
            // Si estamos en modo ruta, añadir waypoint
            if (rutaMode) {
                addWaypoint(e.latlng);
                return;
            }

            // Si estamos siguiendo una ruta, ignorar clicks
            if (siguiendoRuta) {
                return;
            }

            // Comportamiento normal: ir a la posición clickeada
            const targetPos = [e.latlng.lat, e.latlng.lng];
            mover_dron_a_coordenadas(targetPos[0], targetPos[1]);
        });

        // Añadir Waypoint para la ruta
       function addWaypoint(latlng) {
            const waypointNum = waypoints.length + 1;

            // Crear contenedor flotante para elegir tipo de captura
            const popupDiv = document.createElement("div");

            popupDiv.innerHTML = `
                <label style="font-size: 14px;">Captura en este waypoint:</label><br>
                <select id="capturaTipo">
                    <option value="ninguna" selected>Ninguna</option>
                    <option value="foto">Foto</option>
                    <option value="video">Vídeo</option>
                </select><br>
                <div id="duracionDiv" style="display:none;">
                    <label for="duracionInput">Duración vídeo (seg):</label>
                    <input type="number" id="duracionInput" value="5" min="1" style="width:60px;" />
                </div>
                <button id="confirmarWaypointBtn">Confirmar</button>
            `;

            const popup = L.popup()
                .setLatLng(latlng)
                .setContent(popupDiv)
                .openOn(map);

            // Mostrar para escoger duración si se elige video
            popupDiv.querySelector("#capturaTipo").addEventListener("change", function () {
                popupDiv.querySelector("#duracionDiv").style.display = this.value === "video" ? "block" : "none";
            });

            // Confirmar y cerrar
            popupDiv.querySelector("#confirmarWaypointBtn").addEventListener("click", () => {
                const tipo = popupDiv.querySelector("#capturaTipo").value;
                const duracion = tipo === "video" ? parseInt(popupDiv.querySelector("#duracionInput").value) : 0;

                // Guardar el waypoint
                waypoints.push({
                    lat: latlng.lat,
                    lng: latlng.lng,
                    num: waypointNum,
                    captura: tipo,
                    duracion: duracion
                });

                // Elegir color según tipo
                let color = "#FFC107"; // Ninguna
                if (tipo === "foto") color = "#2196F3"; // Azul
                else if (tipo === "video") color = "#F44336"; // Rojo

                const waypointIcon = new WaypointIcon({
                    iconUrl: 'data:image/svg+xml;charset=utf-8,' + encodeURIComponent(createWaypointPinSVG(waypointNum, color))
                });

                const marker = L.marker([latlng.lat, latlng.lng], { icon: waypointIcon }).addTo(map);
                waypointMarkers.push(marker);

                actualizarRutaPolyline();
                map.closePopup();
            });
        }

        // Actualiza la línea negra de la ruta
        function actualizarRutaPolyline() {
            const coordenadas = waypoints.map(wp => [wp.lat, wp.lng]);
            rutaPolyline.setLatLngs(coordenadas);
        }

        // Muestra u oculta la botonera de navegación clásica
        function toggleNavegacion() {
            const nav = document.getElementById('navegacion');
            const btn = document.getElementById('toggleNavegacion');

            if (nav.style.display === 'none') {
                nav.style.display = 'grid';
                btn.textContent = 'Ocultar Nav.';
            } else {
                nav.style.display = 'none';
                btn.textContent = 'Mostrar Nav.';
            }
        }

        // Función para activar/desactivar el seguimiento del dron
        // Funciones para los dropdowns
        function toggleDropdown(menuId) {
            const dropdown = document.getElementById(menuId);
            const allDropdowns = document.querySelectorAll('.dropdown-menu');
            const allToggles = document.querySelectorAll('.dropdown-toggle');
            
            // Cerrar otros dropdowns
            allDropdowns.forEach(d => {
                if (d.id !== menuId) {
                    d.classList.remove('show');
                }
            });
            
            allToggles.forEach(t => {
                const parentDropdown = t.nextElementSibling;
                if (parentDropdown && parentDropdown.id !== menuId) {
                    t.classList.remove('active');
                }
            });
            
            // Toggle del dropdown actual
            dropdown.classList.toggle('show');
            const currentToggle = dropdown.previousElementSibling;
            currentToggle.classList.toggle('active');
        }

        function closeAllDropdowns() {
            const allDropdowns = document.querySelectorAll('.dropdown-menu');
            const allToggles = document.querySelectorAll('.dropdown-toggle');
            
            allDropdowns.forEach(d => d.classList.remove('show'));
            allToggles.forEach(t => t.classList.remove('active'));
        }

        // Cerrar dropdowns al hacer click fuera
        document.addEventListener('click', function(event) {
            const featuresDropdown = document.querySelector('.features-dropdown');
            const modesDropdown = document.querySelector('.modes-dropdown');
            
            if ((featuresDropdown && !featuresDropdown.contains(event.target)) &&
                (modesDropdown && !modesDropdown.contains(event.target))) {
                closeAllDropdowns();
            }
        });

        function toggleFollowDrone() {
            const followButton = document.getElementById('followButton');
            const followIndicator = document.getElementById('follow-indicator');
            
            followDrone = !followDrone;
            
            if (followDrone) {
                // Activar modo seguimiento
                followButton.classList.add('active');
                followButton.title = 'Dejar de seguir';
                
                // Centrar inmediatamente en el dron
                map.setView(currentPos, map.getZoom());
                
                console.log('Modo seguimiento activado: El mapa seguirá al dron');
            } else {
                // Desactivar modo seguimiento
                followButton.classList.remove('active');
                followButton.title = 'Seguir dron';
                
                console.log('Modo seguimiento desactivado');
            }
        }

        // Cambia el botón crear ruta a otro tipo de información (Recorrer ruta)
        function toggleRutaMode() {
            const botonRuta = document.getElementById('botonRuta');

            // Si ya estamos siguiendo una ruta, no hacemos nada
            if (siguiendoRuta) return;

            if (!rutaMode) {
                // Activar modo de creación de ruta
                rutaMode = true;
                botonRuta.textContent = "Recorrer Ruta";
                botonRuta.classList.remove('boton-azul');
                botonRuta.classList.add('boton-amarillo');
            } else {
                // Si hay waypoints, iniciar la ruta
                if (waypoints.length > 0) {
                    iniciarRuta();
                } else {
                    // Si no hay waypoints, volver al modo normal
                    rutaMode = false;
                    botonRuta.textContent = "Crear Ruta";
                    botonRuta.classList.remove('boton-amarillo');
                    botonRuta.classList.add('boton-azul');
                }
            }
        }

        // Función que indica el inicio de una ruta y cambia el botón a: siguiendo ruta
        function iniciarRuta() {
            siguiendoRuta = true;
            rutaMode = false;

            const botonRuta = document.getElementById('botonRuta');
            botonRuta.textContent = "Siguiendo Ruta...";
            botonRuta.classList.remove('boton-amarillo');
            botonRuta.classList.add('boton-rojo');

            // Deshabilitar los otros botones
            document.getElementById('botonConectar').disabled = true;
            document.getElementById('botonDespegar').disabled = true;

            socket.emit('command', { action: 'waypointRuta', waypoints: waypoints });
        }

        // Mover el dron al waypoint indicado
        function moverDronAWaypoint(waypoint) {
            mover_dron_a_coordenadas(waypoint.lat, waypoint.lng);
            console.log('Dron moviéndose al waypoint:', waypoint.num);
        }
        
        // ===== FUNCIONES DE WEBCAM Y CAPTURA =====

        // Función para mostrar u ocultar el contenedor de video
        function toggleWebcamView() {
            const webcamContainer = document.getElementById('webcam-container');
            if (webcamContainer.style.display === 'none') {
                webcamContainer.style.display = 'block';
                document.getElementById('botonImagenDron').textContent = 'Ver Mapa';
            } else {
                webcamContainer.style.display = 'none';
                document.getElementById('botonImagenDron').textContent = 'Cámara Dron';
            }
        }

        // Función para mostrar u ocultar el contenedor de la cámara del móvil
        function abrirVentanaCamara() {
            const camaraContainer = document.getElementById('camara-container');
            if (camaraContainer.style.display === 'none') {
                camaraContainer.style.display = 'block';
                document.getElementById('botonCamaraMovil').textContent = 'Ver Mapa';
                alert("Ponga el móvil en vertical y oculte los botones de navegación para optimizar el uso de esta función.");
            } else {
                camaraContainer.style.display = 'none';
                document.getElementById('botonCamaraMovil').textContent = 'Cámara Móvil';
            }
        }

        // Función para ir al modo piloto
        function irAModoPiloto() {
            window.location.href = '/piloto';
        }

        // Función de capturar foto
        function capturarFoto() {
            console.log("Enviando comando para capturar foto");
            socket.emit('command', { action: 'capturarFoto' });
            // Mostrar feedback visual momentáneo
            const botonCapturarFoto = document.getElementById('botonCapturarFoto');
            botonCapturarFoto.classList.remove('boton-azul');
            botonCapturarFoto.classList.add('boton-verde');
            botonCapturarFoto.textContent = "Foto Hecha";

            // Restaurar el botón después de 2 segundos
            setTimeout(function() {
                botonCapturarFoto.classList.remove('boton-verde');
                botonCapturarFoto.classList.add('boton-azul');
                botonCapturarFoto.textContent = "Hacer Foto";
            }, 2000);
        }

        // Inicia la grabación del vídeo de la cámara del dron
        function iniciarGrabacion() {
            console.log("Enviando comando para iniciar grabación de video");
            socket.emit('command', { action: 'iniciarVideo' });

            // Mostrar feedback visual
            const botonIniciarVideo = document.getElementById('botonIniciarVideo');
            const botonDetenerVideo = document.getElementById('botonDetenerVideo');

            botonIniciarVideo.style.display = 'none';
            botonDetenerVideo.style.display = 'block';
        }

         // Detiene la grabación del vídeo de la cámara del dron
        function detenerGrabacion() {
            console.log("Enviando comando para detener grabación de video");
            socket.emit('command', { action: 'detenerVideo' });

            // Mostrar feedback visual
            const botonIniciarVideo = document.getElementById('botonIniciarVideo');
            const botonDetenerVideo = document.getElementById('botonDetenerVideo');

            botonIniciarVideo.style.display = 'block';
            botonDetenerVideo.style.display = 'none';
        }

        const video = document.getElementById("video");
        const canvas = document.getElementById("canvas");
        const ctx = canvas.getContext("2d");
        const imgStream = document.getElementById("processedStream");
        
        // ===== CONEXIÓN WEBSOCKET (Socket.IO) =====

        // Me conecto por websocket al servidor flask
        const socket = io();
        console.log("Conectado al servidor via Socket.IO");
        
        // Recibir frames de video del dron
        socket.on('stream_frame', function(data) {
            console.log("Recibo frame por Socket.IO");
            document.getElementById('video-stream').src = 'data:image/jpeg;base64,' + data;
        });
        
        // Recibir telemetría del dron
        socket.on('telemetry_info', function(data) {
            telemetry_info = data;

            // Actualizar posición y dirección del dron
            if (data.lat && data.lon) {
                updateDronePosition(data.lat, data.lon, data.heading || 0);
            }

            // Actualizar telemetría en el UI
            const telemetriaDiv = document.getElementById('datos-telemetria');
            telemetriaDiv.innerHTML = `
                <span><strong>Altitud:</strong><span class="dato">${data.alt}m</span></span>
                <span><strong>Velocidad:</strong><span class="dato">${data.groundSpeed.toFixed(2)}m/s</span></span>
                <span><strong>Estado:</strong><span class="dato">${data.state}</span></span>
            `;

            // Detectar si acabamos de aterrizar
            if ((previousDroneState === 'landing' || previousDroneState === 'returning') && 
                data.state === 'connected') {
                if (previousDroneState === 'landing') {
                    showLandedState('botonAterrizar');
                } else if (previousDroneState === 'returning') {
                    showLandedState('botonRTL');
                }
            } else {
                updateButtonStates(data.state);
            }

            if (data.state == "flying") {
                const botonDespegar = document.getElementById('botonDespegar');
                botonDespegar.classList.remove('boton-amarillo');
                botonDespegar.classList.add('boton-verde');
            }

            previousDroneState = data.state;
        });

        // Recibir eventos de video
        socket.on('video_error', function(errorMsg) {
            console.error(`Error en grabación: ${errorMsg}`);
            alert(`Error en grabación: ${errorMsg}`);
            document.getElementById('botonIniciarVideo').style.display = 'block';
            document.getElementById('botonDetenerVideo').style.display = 'none';
        });

        socket.on('flight_name_set', function(flightName) {
            currentFlightName = flightName;
            console.log(`Nombre del vuelo establecido: ${currentFlightName}`);
            const webcamContainer = document.getElementById('webcam-container');
            let flightNameDisplay = document.getElementById('flight-name-display');
            if (!flightNameDisplay) {
                flightNameDisplay = document.createElement('div');
                flightNameDisplay.id = 'flight-name-display';
                flightNameDisplay.style.position = 'absolute';
                flightNameDisplay.style.top = '50px';
                flightNameDisplay.style.left = '10px';
                flightNameDisplay.style.background = 'rgba(0,0,0,0.7)';
                flightNameDisplay.style.color = 'white';
                flightNameDisplay.style.padding = '5px 10px';
                flightNameDisplay.style.borderRadius = '5px';
                flightNameDisplay.style.zIndex = '1001';
                webcamContainer.appendChild(flightNameDisplay);
            }
            flightNameDisplay.textContent = `Vuelo: ${currentFlightName}`;
        });

        socket.on('foto_capturada', function(nombreFoto) {
            let ubicacion = currentFlightName ? `${currentFlightName}/${nombreFoto}` : nombreFoto;
            console.log(`Foto capturada: ${ubicacion}`);
        });

        socket.on('video_iniciado', function(nombreVideo) {
            let ubicacion = currentFlightName ? `${currentFlightName}/${nombreVideo}` : nombreVideo;
            console.log(`Grabación iniciada: ${ubicacion}`);
        });

        socket.on('video_detenido', function() {
            console.log("Grabación detenida");
        });

        // Función para actualizar el estado de todos los botones según el estado del dron
        function updateButtonStates(droneState) {
            const botonConectar = document.getElementById('botonConectar');
            const botonDespegar = document.getElementById('botonDespegar');
            const botonAterrizar = document.getElementById('botonAterrizar');
            const botonRTL = document.getElementById('botonRTL');

            // Resetear clases de todos los botones
            function resetButtonClasses(button) {
                button.classList.remove('boton-verde', 'boton-amarillo', 'boton-rojo');
            }

            switch (droneState) {
                case 'connected':
                    // Dron conectado pero en tierra
                    if (!despegando) {
                        botonDespegar.disabled = false;
                        botonDespegar.textContent = 'Despegar';
                        resetButtonClasses(botonDespegar);
                    }
                    
                    botonAterrizar.disabled = true;
                    botonAterrizar.textContent = 'Aterrizar';
                    resetButtonClasses(botonAterrizar);
                    
                    botonRTL.disabled = true;
                    botonRTL.textContent = 'RTL';
                    resetButtonClasses(botonRTL);
                    break;

                case 'arming':
                    break;
                    
                case 'takingOff':
                    break;

                case 'flying':
                    // Dron volando
                    despegando = false; // Resetear variable cuando esté volando
                    botonDespegar.disabled = true;
                    botonDespegar.textContent = 'Volando';
                    resetButtonClasses(botonDespegar);
                    botonDespegar.classList.add('boton-verde');
                    
                    botonAterrizar.disabled = false;
                    botonAterrizar.textContent = 'Aterrizar';
                    resetButtonClasses(botonAterrizar);
                    
                    botonRTL.disabled = false;
                    botonRTL.textContent = 'RTL';
                    resetButtonClasses(botonRTL);
                    break;

                case 'landing':
                    // Dron aterrizando
                    botonDespegar.disabled = true;
                    botonAterrizar.disabled = true;
                    botonAterrizar.textContent = 'Aterrizando...';
                    resetButtonClasses(botonAterrizar);
                    botonAterrizar.classList.add('boton-amarillo');
                    botonRTL.disabled = true;
                    break;

                case 'returning':
                    // Dron volviendo a base (RTL)
                    botonDespegar.disabled = true;
                    botonAterrizar.disabled = true;
                    botonRTL.disabled = true;
                    botonRTL.textContent = 'Volviendo...';
                    resetButtonClasses(botonRTL);
                    botonRTL.classList.add('boton-amarillo');
                    break;

                default:
                    // Estado desconocido o desconectado
                    botonDespegar.disabled = true;
                    botonDespegar.textContent = 'Despegar';
                    resetButtonClasses(botonDespegar);
                    
                    botonAterrizar.disabled = true;
                    botonAterrizar.textContent = 'Aterrizar';
                    resetButtonClasses(botonAterrizar);
                    
                    botonRTL.disabled = true;
                    botonRTL.textContent = 'RTL';
                    resetButtonClasses(botonRTL);
                    break;
            }
        }

        // Función para mostrar temporalmente estado "En Tierra"
        function showLandedState(buttonId) {
            const button = document.getElementById(buttonId);
            button.textContent = 'En Tierra';
            button.classList.remove('boton-amarillo');
            button.classList.add('boton-verde');
            
            // Después de 3 segundos, resetear al estado base
            setTimeout(() => {
                updateButtonStates('connected');
            }, 3000);
        }

        // Variable para trackear el estado anterior del dron
        let previousDroneState = null;
        
        // Variable para evitar sobrescribir estado manual de despegue
        let despegando = false;

        function conectarDron() {
            console.log("Voy a conectar");
            socket.emit('command', { action: 'connect' });
            const botonConectar = document.getElementById('botonConectar');
            botonConectar.classList.add('boton-verde');
        }

        function despegarDron() {
            const altura = document.getElementById('altura').value;
            if (altura) {
                socket.emit('command', { action: 'arm_takeOff', altura: String(altura) });
                
                despegando = true;
                const botonDespegar = document.getElementById('botonDespegar');
                botonDespegar.textContent = 'Despegando...';
                botonDespegar.classList.add('boton-amarillo');
                botonDespegar.disabled = true;
            } else {
                alert("Por favor, ingrese una altura válida.");
            }
        }

        // Función para despegar el dron mediante gesto o voz con altura específica
        function despegarDronConAltura(altura) {
            // Validar que la altura sea un número válido
            if (!altura || isNaN(altura) || altura <= 0) {
                alert("Por favor, proporcione una altura válida.");
                return;
            }
            
            // Actualizar el campo de altura si existe (opcional, para feedback visual)
            const alturaInput = document.getElementById("altura");
            if (alturaInput) {
                alturaInput.value = altura;
            }
            
            // Configurar estado de despegue
            despegando = true;
            const botonDespegar = document.getElementById('botonDespegar');
            botonDespegar.textContent = 'Despegando...';
            botonDespegar.classList.add('boton-amarillo');
            botonDespegar.disabled = true;
            
            // Enviar comando de despegue con la altura especificada
            socket.emit('command', { action: 'arm_takeOff', altura: String(altura) });
        }

        function aterrizarDron() {
            socket.emit('command', { action: 'Land' });
             
            const botonAterrizar = document.getElementById('botonAterrizar');
            botonAterrizar.textContent = 'Aterrizando...';
            botonAterrizar.classList.add('boton-amarillo');
            botonAterrizar.disabled = true;
        }

        function moverDron(direction) {
            socket.emit('command', { action: 'go', direction: direction });
        }

        function returnToLaunch() {
            socket.emit('command', { action: 'RTL' });
            
            const botonRTL = document.getElementById('botonRTL');
            botonRTL.textContent = 'Volviendo...';
            botonRTL.classList.add('boton-amarillo');
            botonRTL.disabled = true;
        }

        function ajustarAltitud(cantidad) {
            console.log(`Ajustando altitud: ${cantidad}m`);
            socket.emit('command', { action: 'change_altitude', altitude: cantidad });
        }

        // ===== CONTROL POR VOZ =====
        let recognition;
        let recognizing = false;

        function iniciarControlVoz() {
            // Verificar soporte
            const SpeechRecognition = window.SpeechRecognition || window.webkitSpeechRecognition;
            if (!SpeechRecognition) {
                alert('Tu navegador no soporta reconocimiento de voz. Usa Chrome o Safari.');
                return;
            }

            const btn = document.getElementById('voice-control-btn');
            const micIcon = btn.querySelector('.mic-icon');
            const voiceText = btn.querySelector('.voice-text');

            // Si ya está reconociendo, detener
            if (recognizing) {
                if (recognition) recognition.stop();
                recognizing = false;
                btn.classList.remove('listening', 'processing', 'error');
                voiceText.textContent = 'VOZ';
                return;
            }

            // Iniciar reconocimiento
            recognition = new SpeechRecognition();
            recognition.lang = 'es-ES';
            recognition.interimResults = false;
            recognition.maxAlternatives = 1;

            recognition.onstart = function() {
                recognizing = true;
                btn.classList.add('listening');
                voiceText.textContent = 'ESCUCHANDO...';
                console.log('Reconocimiento de voz iniciado');
            };

            recognition.onresult = function(event) {
                const transcript = event.results[0][0].transcript.toLowerCase().trim();
                console.log('Comando reconocido:', transcript);
                
                btn.classList.remove('listening');
                btn.classList.add('processing');
                voiceText.textContent = `"${transcript}"`;

                // Procesar comando
                setTimeout(() => {
                    const exitoso = procesarComandoVoz(transcript);
                    
                    if (exitoso) {
                        setTimeout(() => {
                            btn.classList.remove('processing');
                            voiceText.textContent = 'VOZ';
                            recognizing = false;
                        }, 1500);
                    } else {
                        btn.classList.remove('processing');
                        btn.classList.add('error');
                        voiceText.textContent = 'NO ENTENDIDO';
                        setTimeout(() => {
                            btn.classList.remove('error');
                            voiceText.textContent = 'VOZ';
                            recognizing = false;
                        }, 2000);
                    }
                }, 500);
            };

            recognition.onerror = function(event) {
                console.error('Error de reconocimiento:', event.error);
                btn.classList.remove('listening', 'processing');
                btn.classList.add('error');
                voiceText.textContent = 'ERROR';
                
                setTimeout(() => {
                    btn.classList.remove('error');
                    voiceText.textContent = 'VOZ';
                    recognizing = false;
                }, 2000);
            };

            recognition.onend = function() {
                console.log('Reconocimiento finalizado');
                if (recognizing && !btn.classList.contains('processing') && !btn.classList.contains('error')) {
                    btn.classList.remove('listening');
                    voiceText.textContent = 'VOZ';
                    recognizing = false;
                }
            };

            recognition.start();
        }

        // Función para leer texto en voz alta
        function hablar(texto) {
            // Verificar soporte de síntesis de voz
            if ('speechSynthesis' in window) {
                // Cancelar cualquier habla anterior
                window.speechSynthesis.cancel();
                
                // Crear el mensaje de voz
                const utterance = new SpeechSynthesisUtterance(texto);
                utterance.lang = 'es-ES';
                utterance.rate = 1.0; // Velocidad normal
                utterance.pitch = 1.0; // Tono normal
                utterance.volume = 1.0; // Volumen máximo
                
                // Hablar
                window.speechSynthesis.speak(utterance);
            }
        }

        // Función para convertir palabras numéricas a números
        function palabraANumero(palabra) {
            const numeros = {
                'uno': 1, 'un': 1,
                'dos': 2,
                'tres': 3,
                'cuatro': 4,
                'cinco': 5,
                'seis': 6,
                'siete': 7,
                'ocho': 8,
                'nueve': 9,
                'diez': 10
            };
            return numeros[palabra.toLowerCase()] || null;
        }

        // Función para extraer altura del comando de voz
        function extraerAltura(comando) {
            // Buscar cualquier palabra numérica en el comando
            const palabras = comando.split(' ');
            
            for (let palabra of palabras) {
                // Limpiar la palabra de "metros" si está pegada
                palabra = palabra.replace(/metros?$/i, '').trim();
                
                const numero = palabraANumero(palabra);
                if (numero !== null) {
                    return numero;
                }
            }
            
            return null;
        }

        function procesarComandoVoz(comando) {
            console.log('Procesando comando:', comando);

            // Despegar con altura específica
            if (comando.includes('despega') || comando.includes('despegar') || 
                comando.includes('takeoff') || comando.includes('vuela')) {
                
                // Extraer altura del comando (dígitos o palabras)
                const altura = extraerAltura(comando);
                
                if (altura !== null) {
                    // Validar rango: solo entre 1 y 10 metros
                    if (altura < 1 || altura > 10) {
                        console.log(`Altura fuera de rango: ${altura} metros`);
                        hablar('Solo se puede despegar entre 1 y 10 metros');
                        return false;
                    }
                    
                    console.log(`Ejecutando: Despegar a ${altura} metros`);
                    hablar(`Despegando a ${altura} metros`);
                    despegarDronConAltura(altura);
                } else {
                    // Si no se especifica altura con "a" o "hasta", usar la del campo input
                    console.log('Ejecutando: Despegar');
                    hablar('Despegando');
                    despegarDron();
                }
                return true;
            }

            // Aterrizar
            if (comando.includes('aterriza') || comando.includes('aterrizas') || 
                comando.includes('aterrizar') || comando.includes('land')) {
                console.log('Ejecutando: Aterrizar');
                hablar('Aterrizando');
                aterrizarDron();
                return true;
            }

            // RTL
            if (comando.includes('rtl') || comando.includes('vuelve') || 
                comando.includes('regresa') || comando.includes('base') || 
                comando.includes('casa') || comando.includes('home')) {
                console.log('Ejecutando: RTL');
                hablar('Regresando a base');
                returnToLaunch();
                return true;
            }

            // Para (detener movimiento) - solo si es un comando de una palabra
            const palabrasComando = comando.trim().split(/\s+/);
            if (palabrasComando.length === 1 && 
                (comando === 'para' || comando === 'parar' || 
                 comando === 'quieto' || comando === 'detener' || 
                 comando === 'alto' || comando === 'stop')) {
                console.log('Ejecutando: Parar (detener movimiento)');
                hablar('Deteniendo');
                moverDron('Stop');
                return true;
            }

            // Movimientos direccionales
            if (comando.includes('norte') || comando.includes('adelante') || comando.includes('alante') ||
                comando.includes('avanza') || comando.includes('recto')) {
                console.log('Ejecutando: Mover al norte');
                hablar('Moviendo al norte');
                moverDron('North');
                return true;
            }

            if (comando.includes('sur') || comando.includes('atrás') || 
                comando.includes('retrocede') || comando.includes('backward')) {
                console.log('Ejecutando: Mover al sur');
                hablar('Moviendo al sur');
                moverDron('South');
                return true;
            }

            if (comando.includes('este') || comando.includes('derecha') || 
                comando.includes('right')) {
                console.log('Ejecutando: Mover al este');
                hablar('Moviendo al este');
                moverDron('East');
                return true;
            }

            if (comando.includes('oeste') || comando.includes('izquierda') || 
                comando.includes('left')) {
                console.log('Ejecutando: Mover al oeste');
                hablar('Moviendo al oeste');
                moverDron('West');
                return true;
            }

            // Ajuste de altitud - Subir
            if (comando.includes('sube') || comando.includes('subir') || 
                comando.includes('arriba') || comando.includes('up')) {
                
                // Extraer altura del comando (dígitos o palabras)
                const altura = extraerAltura(comando);
                
                if (altura !== null) {
                    // Validar rango: solo entre 1 y 10 metros
                    if (altura < 1 || altura > 10) {
                        console.log(`Altura fuera de rango: ${altura} metros`);
                        hablar('Solo se puede ajustar entre 1 y 10 metros');
                        return false;
                    }
                    
                    console.log(`Ejecutando: Subir ${altura} metros`);
                    hablar(`Subiendo ${altura} metros`);
                    ajustarAltitud(altura);
                } else {
                    console.log('Ejecutando: Subir altitud (5m por defecto)');
                    hablar('Subiendo 5 metros');
                    ajustarAltitud(5);
                }
                return true;
            }

            if (comando.includes('baja') || comando.includes('bajar') || 
                comando.includes('abajo') || comando.includes('down')) {
                
                // Extraer altura del comando (dígitos o palabras)
                const altura = extraerAltura(comando);
                
                if (altura !== null) {
                    // Validar rango: solo entre 1 y 10 metros
                    if (altura < 1 || altura > 10) {
                        console.log(`Altura fuera de rango: ${altura} metros`);
                        hablar('Solo se puede ajustar entre 1 y 10 metros');
                        return false;
                    }
                    
                    console.log(`Ejecutando: Bajar ${altura} metros`);
                    hablar(`Bajando ${altura} metros`);
                    ajustarAltitud(-altura);
                } else {
                    console.log('Ejecutando: Bajar altitud (5m por defecto)');
                    hablar('Bajando 5 metros');
                    ajustarAltitud(-5);
                }
                return true;
            }

            // Comando no reconocido
            console.warn('Comando no reconocido:', comando);
            hablar('Comando no reconocido');
            return false;
        }

        function mover_dron_a_coordenadas(lat, lng) {
            const mensaje = { lat: lat, lng: lng };
            console.log(`Enviando comando goto: ${JSON.stringify(mensaje)}`);
            socket.emit('command', { action: 'goto', lat: lat, lng: lng });
        }

        // Función para seguir una ruta de waypoints
        let is_following_route = false;
        function seguir_ruta_waypoints(waypoints) {
        try {
            // Marcamos que el dron está siguiendo una ruta
            is_following_route = true;

            // Enviamos la información de la ruta
            const mensaje = JSON.stringify({
                "waypoints": waypoints
            });

            console.log(`Iniciando seguimiento de ruta con ${waypoints.length} waypoints`);

            return true;
            } catch (error) {
            console.error(`Error al iniciar seguimiento de ruta: ${error}`);
            is_following_route = false;
            return false;
            }
        }

        // Indico que no quiero ver el video del movil en la pantalla
        video.style.display = 'none';
        let cam;

        // Activo la cámara frontal del móvil
        function frontCamera() {
        // Elijo la cámara frontal
            cam = "user";
            const botonFront = document.getElementById('botonFront');
            botonFront.classList.add('boton-verde');

            startVideo();
        }

        // Activo la cámara trasera del móvil (he desactivado esta opción para que la atención se la lleve la cámara frontal, pero funcionaria exactamente igual)
        function backCamera () {
        // Elijo la cámara trasera
            const botonBack = document.getElementById('botonBack');
            botonBack.classList.add('boton-verde');

            cam = "environment";
            startVideo();
        }

        // Inicio el video del móvil
        function startVideo() {
        // Verificar si getUserMedia es soportado por el navegador
            if (navigator.mediaDevices.getUserMedia) {
                 // Aqui le indico la cámara que quiero
                 navigator.mediaDevices.getUserMedia({
                     video: { facingMode: cam }
                 }).then(function(stream) {
                     // Asignar el stream al elemento de video
                     video.srcObject = stream;
                     sendFrames();

                 })
                   .catch(function(error) {
                        console.log("Error al acceder a la cámara: ", error);
                   });
            } else {
                 alert("getUserMedia no está soportado por este navegador.");
            }
        }

        // Envio el video del móvil al servidor para que lo procese
        function sendFrames() {
            setInterval(() => {
                canvas.width = video.videoWidth;
                canvas.height = video.videoHeight;
                ctx.drawImage(video, 0, 0, canvas.width, canvas.height);
                let frame = canvas.toDataURL("image/jpeg"); // Convertir a base64
                socket.emit("frame_from_camera", frame); // Enviar frame al servidor
            }, 200); // 200ms es 5 FPS, 66ms es 15 FPS y 33ms es 30 FPS
        }

        // Recibir frames procesados del servidor y mostrarlos
        socket.on("processed_frame", function (data) {
            imgStream.src = data; // Mostrar el frame recibido
        });

        // Recibo despegar desde mediapipe
        socket.on('arm_takeOff', function(data) {
            console.log ("WebApp recibe despegar");
            despegarDronConAltura(data);
        });

        // Recibo aterrizar desde mediapipe
        socket.on('Land', function() {
            console.log ("WebApp recibe aterrizar");
            aterrizarDron();
        });

        // Recibo mover o stop desde mediapipe
        socket.on('go', function(data) {
            console.log ("WebApp recibe go");
            moverDron(data);
        });

        // cuando me pidan los datos de telemetría entrego los valores que tengo para esos datos
        function obtenerDatosTelemetria() {
        // La telemetría ya se está recibiendo en el event listener de 'message'
        // Esta función devuelve los datos más recientes

            if (telemetry_info) {
                return {
                    estado: "success",
                    data: {
                        lat: telemetry_info.lat,
                        lon: telemetry_info.lon,
                        alt: telemetry_info.alt,
                        velocidad: telemetry_info.groundSpeed,
                        direccion: telemetry_info.heading,
                        estado: telemetry_info.state
                    }
                };
            } else {
                return {
                    estado: "fail",
                    message: "Aún no hay datos de telemetría"
                };
            }
        }
        
        // ===== CONTROL JOYSTICK (DISPOSITIVOS TÁCTILES) =====

        // JOYSTICK FLOTANTE - Variables globales
        // Variables globales del joystick
        let joystickActive = false;
        let joystickStartX, joystickStartY;
        let joystickContainer, joystickKnob, joystickArea;
        let joystickInterval = null;
        let joystickMaxDistance = 55; // Distancia máxima fija

        // Inicializar referencias a elementos del joystick
        function initJoystick() {
            joystickArea = document.getElementById('joystick-area');
            joystickContainer = document.getElementById('joystick-container');
            joystickKnob = document.getElementById('joystick-knob');
        }

        // Función para mostrar el joystick en una posición específica
        function showJoystick(x, y) {
            // En dispositivos táctiles, el joystick es fijo, solo resetear
            if (IS_TOUCH_DEVICE) {
                resetJoystickKnob();
                return;
            }
            
            // En dispositivos no táctiles, comportamiento original
            joystickContainer.style.left = (x - 90) + 'px';
            joystickContainer.style.top = (y - 90) + 'px';
            joystickContainer.style.display = 'block';
            resetJoystickKnob();
        }

        // Función para ocultar el joystick
        function hideJoystick() {
            joystickActive = false;
            if (joystickInterval) {
                clearInterval(joystickInterval);
                joystickInterval = null;
            }
            // Enviar comando de parada
            moverDron('Stop');
            
            // En dispositivos táctiles, solo resetear knob, no ocultar
            if (IS_TOUCH_DEVICE) {
                resetJoystickKnob();
                return;
            }
            
            // En dispositivos no táctiles, ocultar completamente
            joystickContainer.style.display = 'none';
        }

        // Función para resetear la posición del knob al centro
        function resetJoystickKnob() {
            joystickKnob.style.transform = 'translate(-50%, -50%)';
        }

        // Función para actualizar la posición del knob
        function updateJoystickKnob(deltaX, deltaY) {
            const distance = Math.sqrt(deltaX * deltaX + deltaY * deltaY);
            
            if (distance <= joystickMaxDistance) {
                joystickKnob.style.transform = `translate(calc(-50% + ${deltaX}px), calc(-50% + ${deltaY}px))`;
            } else {
                // Limitar el knob al borde del joystick
                const angle = Math.atan2(deltaY, deltaX);
                const limitedX = Math.cos(angle) * joystickMaxDistance;
                const limitedY = Math.sin(angle) * joystickMaxDistance;
                joystickKnob.style.transform = `translate(calc(-50% + ${limitedX}px), calc(-50% + ${limitedY}px))`;
                deltaX = limitedX;
                deltaY = limitedY;
            }
            
            return { x: deltaX, y: deltaY };
        }

        // Función para convertir la posición del joystick a comando de dirección
        function joystickToDirection(deltaX, deltaY) {

            const distance = Math.sqrt(deltaX * deltaX + deltaY * deltaY);
            
            const threshold = 15;
                        
            if (distance < threshold) {
                return 'Stop';
            }
            
            // Calcular ángulo (0° = Este, 90° = Norte, 180° = Oeste, 270° = Sur)
            let angle = Math.atan2(-deltaY, deltaX) * 180 / Math.PI; // -deltaY porque Y crece hacia abajo
            if (angle < 0) angle += 360;
            
            console.log(`Debug angle: ${angle.toFixed(1)}°`);
            
            // Convertir ángulo a dirección cardinal/intercardinal
            if (angle >= 337.5 || angle < 22.5) return 'East';
            else if (angle >= 22.5 && angle < 67.5) return 'NorthEast';
            else if (angle >= 67.5 && angle < 112.5) return 'North';
            else if (angle >= 112.5 && angle < 157.5) return 'NorthWest';
            else if (angle >= 157.5 && angle < 202.5) return 'West';
            else if (angle >= 202.5 && angle < 247.5) return 'SouthWest';
            else if (angle >= 247.5 && angle < 292.5) return 'South';
            else if (angle >= 292.5 && angle < 337.5) return 'SouthEast';
            
            return 'Stop';
        }

        // Variable para almacenar la última dirección enviada
        let lastDirection = 'Stop';

        // Función para enviar comandos del joystick al dron
        function sendJoystickCommand(deltaX, deltaY) {
            const direction = joystickToDirection(deltaX, deltaY);
            
            // Debug: mostrar valores
            console.log(`Debug Joystick - deltaX: ${deltaX.toFixed(1)}, deltaY: ${deltaY.toFixed(1)}, direction: ${direction}`);
            
            // Solo enviar comando si la dirección ha cambiado
            if (direction !== lastDirection) {
                console.log(`Joystick: ${direction} (deltaX: ${deltaX.toFixed(1)}, deltaY: ${deltaY.toFixed(1)})`);
                moverDron(direction);
                lastDirection = direction;
            }
        }

        // Variables adicionales para tracking táctil
        let currentTouchX = 0;
        let currentTouchY = 0;

        // Event listeners para eventos táctiles (móviles/tablets)
        function setupJoystickTouchEvents() {
            joystickArea.addEventListener('touchstart', function(e) {
                e.preventDefault();
                const touch = e.touches[0];
                const rect = joystickArea.getBoundingClientRect();
                const x = touch.clientX - rect.left;
                const y = touch.clientY - rect.top;
                
                joystickActive = true;
                
                // Coordenadas fijas del joystick (solo dispositivos táctiles llegan aquí)
                joystickStartX = 100 + 60; // left + radius
                joystickStartY = window.innerHeight - 100 - 60; // height - bottom - radius
                
                showJoystick(x, y);
                
                console.log('Touch START:', {x, y, joystickStartX, joystickStartY, isTouch: IS_TOUCH_DEVICE});
                
                // Iniciar envío periódico de comandos
                joystickInterval = setInterval(() => {
                    if (joystickActive && currentTouchX !== 0 && currentTouchY !== 0) {
                        const deltaX = currentTouchX - joystickStartX;
                        const deltaY = currentTouchY - joystickStartY;
                        const limited = updateJoystickKnob(deltaX, deltaY);
                        sendJoystickCommand(limited.x, limited.y);
                    }
                }, 150); // Enviar comandos cada 150ms
            });

            joystickArea.addEventListener('touchmove', function(e) {
                e.preventDefault();
                if (!joystickActive) return;
                
                const touch = e.touches[0];
                
                // Usar coordenadas globales (solo dispositivos táctiles llegan aquí)
                currentTouchX = touch.clientX;
                currentTouchY = touch.clientY;
                
                const deltaX = currentTouchX - joystickStartX;
                const deltaY = currentTouchY - joystickStartY;
                
                console.log('Touch MOVE:', {currentTouchX, currentTouchY, deltaX, deltaY});
                
                // Actualizar posición del knob inmediatamente
                const limited = updateJoystickKnob(deltaX, deltaY);
            });

            joystickArea.addEventListener('touchend', function(e) {
                e.preventDefault();
                console.log('Touch END');
                // Resetear las coordenadas táctiles
                currentTouchX = 0;
                currentTouchY = 0;
                hideJoystick();
                lastDirection = 'Stop';
            });
        }

        // Event listeners para eventos de mouse (para testing en desktop)
        function setupJoystickMouseEvents() {
            joystickArea.addEventListener('mousedown', function(e) {
                e.preventDefault();
                const rect = joystickArea.getBoundingClientRect();
                const x = e.clientX - rect.left;
                const y = e.clientY - rect.top;
                
                joystickActive = true;
                joystickStartX = x;
                joystickStartY = y;
                showJoystick(x, y);
                
                // Iniciar envío periódico de comandos
                joystickInterval = setInterval(() => {
                    if (joystickActive) {
                        // Usar las coordenadas actuales del mouse
                        const currentRect = joystickArea.getBoundingClientRect();
                        // Nota: para mouse necesitamos trackear la posición actual
                    }
                }, 150);
            });

            joystickArea.addEventListener('mousemove', function(e) {
                if (!joystickActive) return;
                
                const rect = joystickArea.getBoundingClientRect();
                const deltaX = (e.clientX - rect.left) - joystickStartX;
                const deltaY = (e.clientY - rect.top) - joystickStartY;
                
                const limited = updateJoystickKnob(deltaX, deltaY);
                sendJoystickCommand(limited.x, limited.y);
            });

            joystickArea.addEventListener('mouseup', function(e) {
                e.preventDefault();
                hideJoystick();
                lastDirection = 'Stop';
            });

            // Manejar cuando el mouse sale del área
            joystickArea.addEventListener('mouseleave', function(e) {
                if (joystickActive) {
                    hideJoystick();
                    lastDirection = 'Stop';
                }
            });
        }
        
        // ===== INICIALIZACIÓN DE LA APLICACIÓN =====

        // Inicializar el joystick cuando se carga la página
        document.addEventListener('DOMContentLoaded', function() {
            // Configurar interfaz según tipo de dispositivo
            setupDeviceSpecificUI();
            
            // Inicializar funcionalidad del joystick
            initJoystick();
            setupJoystickTouchEvents();
            setupJoystickMouseEvents();
        });
        
        // Función para configurar la UI según el tipo de dispositivo
        function setupDeviceSpecificUI() {
            const joystickContainer = document.getElementById('joystick-container');
            const joystickArea = document.getElementById('joystick-area');
            const navegacion = document.getElementById('navegacion');
            const toggleNavBtn = document.getElementById('toggleNavegacion');
            
            if (IS_TOUCH_DEVICE) {
                // Dispositivo táctil: mostrar joystick fijo, ocultar cruceta
                if (joystickContainer) {
                    joystickContainer.classList.add('touch-device');
                }
                if (joystickArea) {
                    joystickArea.classList.remove('non-touch-hidden');
                }
                if (navegacion) {
                    navegacion.classList.add('touch-hidden');
                }
                if (toggleNavBtn) {
                    toggleNavBtn.style.display = 'none';
                }
                console.log('Configurado para dispositivo táctil: Joystick visible, cruceta oculta');
            } else {
                // Dispositivo no táctil: ocultar joystick completamente, mostrar cruceta
                if (joystickContainer) {
                    joystickContainer.classList.remove('touch-device');
                }
                if (joystickArea) {
                    joystickArea.classList.add('non-touch-hidden');
                }
                if (navegacion) {
                    navegacion.classList.remove('touch-hidden');
                }
                console.log('Configurado para dispositivo no táctil: Cruceta visible, joystick completamente oculto');
            }
        }
        
    </script>
</body>
</html>
